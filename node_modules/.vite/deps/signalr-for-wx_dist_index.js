import "./chunk-IVLCYF2H.js";

// ../../../流沙任务系统uniapp/uniapp_flow/node_modules/signalr-for-wx/dist/IHubProtocol.js
var MessageType;
(function(MessageType2) {
  MessageType2[MessageType2["Invocation"] = 1] = "Invocation";
  MessageType2[MessageType2["StreamItem"] = 2] = "StreamItem";
  MessageType2[MessageType2["Completion"] = 3] = "Completion";
  MessageType2[MessageType2["StreamInvocation"] = 4] = "StreamInvocation";
  MessageType2[MessageType2["CancelInvocation"] = 5] = "CancelInvocation";
  MessageType2[MessageType2["Ping"] = 6] = "Ping";
  MessageType2[MessageType2["Close"] = 7] = "Close";
})(MessageType || (MessageType = {}));

// ../../../流沙任务系统uniapp/uniapp_flow/node_modules/signalr-for-wx/dist/ILogger.js
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["Trace"] = 0] = "Trace";
  LogLevel2[LogLevel2["Debug"] = 1] = "Debug";
  LogLevel2[LogLevel2["Information"] = 2] = "Information";
  LogLevel2[LogLevel2["Warning"] = 3] = "Warning";
  LogLevel2[LogLevel2["Error"] = 4] = "Error";
  LogLevel2[LogLevel2["Critical"] = 5] = "Critical";
  LogLevel2[LogLevel2["None"] = 6] = "None";
})(LogLevel || (LogLevel = {}));

// ../../../流沙任务系统uniapp/uniapp_flow/node_modules/signalr-for-wx/dist/ITransport.js
var HttpTransportType;
(function(HttpTransportType2) {
  HttpTransportType2[HttpTransportType2["None"] = 0] = "None";
  HttpTransportType2[HttpTransportType2["WebSockets"] = 1] = "WebSockets";
  HttpTransportType2[HttpTransportType2["LongPolling"] = 4] = "LongPolling";
})(HttpTransportType || (HttpTransportType = {}));
var TransferFormat;
(function(TransferFormat2) {
  TransferFormat2[TransferFormat2["Text"] = 1] = "Text";
  TransferFormat2[TransferFormat2["Binary"] = 2] = "Binary";
})(TransferFormat || (TransferFormat = {}));

// ../../../流沙任务系统uniapp/uniapp_flow/node_modules/signalr-for-wx/dist/Loggers.js
var NullLogger = (
  /** @class */
  function() {
    function NullLogger2() {
    }
    NullLogger2.prototype.log = function(logLevel) {
      var msg = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        msg[_i - 1] = arguments[_i];
      }
    };
    NullLogger2.instance = new NullLogger2();
    return NullLogger2;
  }()
);

// ../../../流沙任务系统uniapp/uniapp_flow/node_modules/signalr-for-wx/dist/TextMessageFormat.js
var TextMessageFormat = (
  /** @class */
  function() {
    function TextMessageFormat2() {
    }
    TextMessageFormat2.write = function(output) {
      return "" + output + TextMessageFormat2.RecordSeparator;
    };
    TextMessageFormat2.parse = function(input) {
      if (input[input.length - 1] !== TextMessageFormat2.RecordSeparator) {
        throw new Error("Message is incomplete.");
      }
      var messages = input.split(TextMessageFormat2.RecordSeparator);
      messages.pop();
      return messages;
    };
    TextMessageFormat2.RecordSeparatorCode = 30;
    TextMessageFormat2.RecordSeparator = String.fromCharCode(TextMessageFormat2.RecordSeparatorCode);
    return TextMessageFormat2;
  }()
);

// ../../../流沙任务系统uniapp/uniapp_flow/node_modules/signalr-for-wx/dist/JsonHubProtocol.js
var JSON_HUB_PROTOCOL_NAME = "json";
var JsonHubProtocol = (
  /** @class */
  function() {
    function JsonHubProtocol2() {
      this.name = JSON_HUB_PROTOCOL_NAME;
      this.version = 1;
      this.transferFormat = TransferFormat.Text;
    }
    JsonHubProtocol2.prototype.parseMessages = function(input, logger) {
      if (typeof input !== "string") {
        throw new Error("Invalid input for JSON hub protocol. Expected a string. (fy:包含一个无效的JSON协议输入,但是这里需要输入string 消息)");
      }
      if (!input) {
        return [];
      }
      if (logger === null) {
        logger = NullLogger.instance;
      }
      var messages = TextMessageFormat.parse(input);
      var hubMessages = [];
      for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {
        var message = messages_1[_i];
        var parsedMessage = JSON.parse(message);
        if (typeof parsedMessage.type !== "number") {
          throw new Error("Invalid payload. (fy: 无效的消息)");
        }
        switch (parsedMessage.type) {
          case MessageType.Invocation:
            this.isInvocationMessage(parsedMessage);
            break;
          case MessageType.StreamItem:
            this.isStreamItemMessage(parsedMessage);
            break;
          case MessageType.Completion:
            this.isCompletionMessage(parsedMessage);
            break;
          case MessageType.Ping:
            break;
          case MessageType.Close:
            break;
          default:
            logger.log(LogLevel.Information, "Unknown message type '" + parsedMessage.type + "' ignored.");
            continue;
        }
        hubMessages.push(parsedMessage);
      }
      return hubMessages;
    };
    JsonHubProtocol2.prototype.writeMessage = function(message) {
      return TextMessageFormat.write(JSON.stringify(message));
    };
    JsonHubProtocol2.prototype.isInvocationMessage = function(message) {
      this.assertNotEmptyString(message.target, "Invalid payload for Invocation message.");
      if (message.invocationId !== void 0) {
        this.assertNotEmptyString(message.invocationId, "Invalid payload for Invocation message. (fy:无效的 [调用] 消息)");
      }
    };
    JsonHubProtocol2.prototype.isStreamItemMessage = function(message) {
      this.assertNotEmptyString(message.invocationId, "Invalid payload for StreamItem message. (fy:无效的 [StreamItem] 消息)");
      if (message.item === void 0) {
        throw new Error("Invalid payload for StreamItem message. (fy:无效的 [StreamItem] 消息)");
      }
    };
    JsonHubProtocol2.prototype.isCompletionMessage = function(message) {
      if (message.result && message.error) {
        throw new Error("Invalid payload for Completion message (fy:消息不完整).");
      }
      if (!message.result && message.error) {
        this.assertNotEmptyString(message.error, "Invalid payload for Completion message (fy:消息不完整).");
      }
      this.assertNotEmptyString(message.invocationId, "Invalid payload for Completion message (fy:消息不完整).");
    };
    JsonHubProtocol2.prototype.assertNotEmptyString = function(value, errorMessage) {
      if (typeof value !== "string" || value === "") {
        throw new Error(errorMessage);
      }
    };
    return JsonHubProtocol2;
  }()
);

// ../../../流沙任务系统uniapp/uniapp_flow/node_modules/signalr-for-wx/dist/AbortController.js
var AbortController = (
  /** @class */
  function() {
    function AbortController2() {
      this.isAborted = false;
      this.onabort = null;
    }
    AbortController2.prototype.abort = function() {
      if (!this.isAborted) {
        this.isAborted = true;
        if (this.onabort) {
          this.onabort();
        }
      }
    };
    Object.defineProperty(AbortController2.prototype, "signal", {
      get: function() {
        return this;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(AbortController2.prototype, "aborted", {
      get: function() {
        return this.isAborted;
      },
      enumerable: true,
      configurable: true
    });
    return AbortController2;
  }()
);

// ../../../流沙任务系统uniapp/uniapp_flow/node_modules/signalr-for-wx/dist/Errors.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var HttpError = (
  /** @class */
  function(_super) {
    __extends(HttpError2, _super);
    function HttpError2(errorMessage, statusCode) {
      var _newTarget = this.constructor;
      var _this = this;
      var trueProto = _newTarget.prototype;
      _this = _super.call(this, errorMessage) || this;
      _this.statusCode = statusCode;
      _this.__proto__ = trueProto;
      return _this;
    }
    return HttpError2;
  }(Error)
);
var TimeoutError = (
  /** @class */
  function(_super) {
    __extends(TimeoutError2, _super);
    function TimeoutError2(errorMessage) {
      var _newTarget = this.constructor;
      if (errorMessage === void 0) {
        errorMessage = "A timeout occurred.";
      }
      var _this = this;
      var trueProto = _newTarget.prototype;
      _this = _super.call(this, errorMessage) || this;
      _this.__proto__ = trueProto;
      return _this;
    }
    return TimeoutError2;
  }(Error)
);
var AbortError = (
  /** @class */
  function(_super) {
    __extends(AbortError2, _super);
    function AbortError2(errorMessage) {
      var _newTarget = this.constructor;
      if (errorMessage === void 0) {
        errorMessage = "An abort occurred.";
      }
      var _this = this;
      var trueProto = _newTarget.prototype;
      _this = _super.call(this, errorMessage) || this;
      _this.__proto__ = trueProto;
      return _this;
    }
    return AbortError2;
  }(Error)
);
var EventNotFoundError = (
  /** @class */
  function(_super) {
    __extends(EventNotFoundError2, _super);
    function EventNotFoundError2(invocationMessage, errorMessage) {
      var _newTarget = this.constructor;
      if (errorMessage === void 0) {
        errorMessage = "message event not found.";
      }
      var _this = this;
      var trueProto = _newTarget.prototype;
      _this = _super.call(this, errorMessage) || this;
      _this.methodName = invocationMessage.target;
      _this.invocationMessage = invocationMessage;
      _this.__proto__ = trueProto;
      return _this;
    }
    return EventNotFoundError2;
  }(Error)
);

// ../../../流沙任务系统uniapp/uniapp_flow/node_modules/signalr-for-wx/dist/wx-request/model/ResponseType.js
var ResponseType;
(function(ResponseType2) {
  ResponseType2["JSON"] = "json";
  ResponseType2["TEXT"] = "text";
  ResponseType2["ARRAY_BUFFER"] = "arraybuffer";
})(ResponseType || (ResponseType = {}));

// ../../../流沙任务系统uniapp/uniapp_flow/node_modules/signalr-for-wx/dist/Utils.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __spreadArrays = function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
};
var Arg = (
  /** @class */
  function() {
    function Arg2() {
    }
    Arg2.isRequired = function(val, name) {
      if (val === null || val === void 0) {
        throw new Error("The '" + name + "' argument is required.");
      }
    };
    Arg2.isIn = function(val, values, name) {
      if (!(val in values)) {
        throw new Error("Unknown " + name + " value: " + val + ".");
      }
    };
    Arg2.validationUrlIsSupportByWechat = function(url) {
      if (!url) {
        throw new Error("Url is undefined.");
      } else if (!/^(ws|wws):\/\//.test(url)) {
        if (/^http/.test(url)) {
          return url.replace(/^http/, "wx");
        }
        throw new Error("error: instantiation [url](" + url + ") not supported by wechat miniprogram.");
      } else {
        return url;
      }
    };
    return Arg2;
  }()
);
function getDataDetail(data, includeContent) {
  var detail = "";
  if (isArrayBuffer(data)) {
    detail = "Binary data of length " + data.byteLength;
    if (includeContent) {
      detail += ". Content: '" + formatArrayBuffer(data) + "'";
    }
  } else if (typeof data === "string") {
    detail = "String data of length " + data.length;
    if (includeContent) {
      detail += ". Content: '" + data + "'";
    }
  }
  return detail;
}
function formatArrayBuffer(data) {
  var view = new Uint8Array(data);
  var str = "";
  view.forEach(function(num) {
    var pad = num < 16 ? "0" : "";
    str += "0x" + pad + num.toString(16) + " ";
  });
  return str.substr(0, str.length - 1);
}
function isArrayBuffer(val) {
  return val && typeof ArrayBuffer !== "undefined" && (val instanceof ArrayBuffer || // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof
  val.constructor && val.constructor.name === "ArrayBuffer");
}
function sendMessage(logger, transportName, request, url, accessTokenFactory, content, logMessageContent) {
  return __awaiter(this, void 0, void 0, function() {
    var headers, token, responseType, response;
    var _a;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          if (!accessTokenFactory)
            return [3, 2];
          return [4, accessTokenFactory()];
        case 1:
          token = _b.sent();
          if (token) {
            headers = (_a = {}, _a["Authorization"] = "Bearer " + token, _a);
          }
          _b.label = 2;
        case 2:
          logger.log(LogLevel.Trace, "(" + transportName + " transport) sending data. " + getDataDetail(content, logMessageContent) + ".");
          responseType = isArrayBuffer(content) ? ResponseType.ARRAY_BUFFER : ResponseType.TEXT;
          return [4, request.post(url, content, {
            headers,
            responseType
          })];
        case 3:
          response = _b.sent();
          logger.log(LogLevel.Trace, "(" + transportName + " transport) request complete. Response status: " + response.statusCode + ".");
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function createLogger(logger) {
  if (logger === void 0) {
    return new ConsoleLogger(LogLevel.Information);
  }
  if (logger === null) {
    return NullLogger.instance;
  }
  if (logger.log) {
    return logger;
  }
  return new ConsoleLogger(logger);
}
var Subject = (
  /** @class */
  function() {
    function Subject2(cancelCallback) {
      this.observers = [];
      this.cancelCallback = cancelCallback;
    }
    Subject2.prototype.next = function(item) {
      for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {
        var observer = _a[_i];
        observer.next(item);
      }
    };
    Subject2.prototype.error = function(err) {
      for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {
        var observer = _a[_i];
        if (observer.error) {
          observer.error(err);
        }
      }
    };
    Subject2.prototype.complete = function() {
      for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {
        var observer = _a[_i];
        if (observer.complete) {
          observer.complete();
        }
      }
    };
    Subject2.prototype.subscribe = function(observer) {
      this.observers.push(observer);
      return new SubjectSubscription(this, observer);
    };
    return Subject2;
  }()
);
var SubjectSubscription = (
  /** @class */
  function() {
    function SubjectSubscription2(subject, observer) {
      this.subject = subject;
      this.observer = observer;
    }
    SubjectSubscription2.prototype.dispose = function() {
      var index = this.subject.observers.indexOf(this.observer);
      if (index > -1) {
        this.subject.observers.splice(index, 1);
      }
      if (this.subject.observers.length === 0) {
        this.subject.cancelCallback().catch(function(_) {
        });
      }
    };
    return SubjectSubscription2;
  }()
);
var ConsoleLogger = (
  /** @class */
  function() {
    function ConsoleLogger2(minimumLogLevel) {
      this.minimumLogLevel = minimumLogLevel;
    }
    ConsoleLogger2.prototype.log = function() {
      var msg = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        msg[_i] = arguments[_i];
      }
      var logLevel = LogLevel.Information;
      for (var _a = 0, _b = arguments; _a < _b.length; _a++) {
        var ll = _b[_a];
        if (Object.values(LogLevel).indexOf(ll) != -1) {
          logLevel = ll;
          break;
        }
      }
      if (logLevel >= this.minimumLogLevel) {
        switch (logLevel) {
          case LogLevel.Critical:
          case LogLevel.Error:
            console.error.apply(console, __spreadArrays(["[" + (/* @__PURE__ */ new Date()).toISOString() + "] " + LogLevel[logLevel] + " =>"], msg.slice(1, msg.length)));
            break;
          case LogLevel.Warning:
            console.warn.apply(console, __spreadArrays(["[" + (/* @__PURE__ */ new Date()).toISOString() + "] " + LogLevel[logLevel] + " =>"], msg));
            break;
          case LogLevel.Information:
            console.info.apply(console, __spreadArrays(["[" + (/* @__PURE__ */ new Date()).toISOString() + "] " + LogLevel[logLevel] + " =>"], msg));
            break;
          default:
            console.log.apply(console, __spreadArrays(["[" + (/* @__PURE__ */ new Date()).toISOString() + "] " + LogLevel[logLevel] + " =>"], msg));
            break;
        }
      }
    };
    return ConsoleLogger2;
  }()
);

// ../../../流沙任务系统uniapp/uniapp_flow/node_modules/signalr-for-wx/dist/wx-request/model/RequestMethod.js
var RequestMethod;
(function(RequestMethod2) {
  RequestMethod2["GET"] = "GET";
  RequestMethod2["POST"] = "POST";
  RequestMethod2["PUT"] = "PUT";
  RequestMethod2["DELETE"] = "DELETE";
})(RequestMethod || (RequestMethod = {}));

// ../../../流沙任务系统uniapp/uniapp_flow/node_modules/signalr-for-wx/dist/wx-request/index.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator2 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var Request = (
  /** @class */
  function() {
    function Request2(config, logger) {
      if (config === void 0) {
        config = {};
      }
      if (wx) {
        this.logger = logger ? logger : new NullLogger();
      } else {
        throw new Error("当前运行环境不是微信运行环境");
      }
      this.setConfig(config);
    }
    Request2.prototype.setConfig = function(config) {
      if (config === void 0) {
        config = {};
      }
      this.config = __assign({ baseUrl: "http://", headers: { "Content-Type": "application/json" }, forceEnableHttps: false, method: RequestMethod.GET, responseType: ResponseType.JSON, responseEncoding: "utf8", timeout: 60 * 1e3, transformRequest: [], transformResponse: [] }, config);
      if (!this.config.transformResponse) {
        this.config.transformResponse = [];
      }
      this.logger.log(LogLevel.Information, "set config success.");
    };
    Request2.prototype.handleRequestOptions = function(options) {
      return __awaiter2(this, void 0, void 0, function() {
        var _i, _a, fun, e_1;
        return __generator2(this, function(_b) {
          switch (_b.label) {
            case 0:
              if (options.url && !/:\/\/.+?/.test(options.url)) {
                options.url = ((options.config ? options.config.baseUrl : "") + "/" + options.url).replace(/([^:])(\/\/)/g, "$1/");
              }
              this.logger.log(LogLevel.Trace, "checked request url");
              if (options.config && options.config.forceEnableHttps) {
                options.url = options.url.replace(/http:/, "https:");
                this.logger.log(LogLevel.Trace, "execute fix [request.config.forceEnableHttps] " + options.url);
              }
              options.headers = Object.assign({}, options.config ? options.config.headers : {}, options.headers);
              this.logger.log(LogLevel.Trace, "merge headers ", options.headers);
              delete options.headers["Referer"];
              this.logger.log(LogLevel.Trace, "try delete headers Referer.");
              options.responseType = options.responseType ? options.responseType : options.config ? options.config.responseType : ResponseType.TEXT;
              this.logger.log(LogLevel.Trace, "checked responseType [" + options.responseType + "]");
              if (!(options.config && options.config.transformRequest))
                return [3, 6];
              this.logger.log(LogLevel.Trace, "execute transform request list. -result\n", options.config);
              _i = 0, _a = options.config.transformRequest;
              _b.label = 1;
            case 1:
              if (!(_i < _a.length))
                return [3, 6];
              fun = _a[_i];
              _b.label = 2;
            case 2:
              _b.trys.push([2, 4, , 5]);
              return [4, fun(options)];
            case 3:
              _b.sent();
              return [3, 5];
            case 4:
              e_1 = _b.sent();
              throw e_1;
            case 5:
              _i++;
              return [3, 1];
            case 6:
              this.logger.log(LogLevel.Debug, "handled request options \n", options);
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Request2.prototype.handleResponse = function(response) {
      return __awaiter2(this, void 0, void 0, function() {
        var _i, _a, fun, res_1;
        return __generator2(this, function(_b) {
          switch (_b.label) {
            case 0:
              if (!(response.options.config && response.options.config.responseType == "json" && response.options.config.transformResponse))
                return [3, 6];
              _i = 0, _a = response.options.config.transformResponse;
              _b.label = 1;
            case 1:
              if (!(_i < _a.length))
                return [3, 6];
              fun = _a[_i];
              _b.label = 2;
            case 2:
              _b.trys.push([2, 4, , 5]);
              return [4, fun(response)];
            case 3:
              _b.sent();
              return [3, 5];
            case 4:
              res_1 = _b.sent();
              this.logger.log(LogLevel.Trace, "execute transform request list. -result \n ", res_1);
              throw res_1;
            case 5:
              _i++;
              return [3, 1];
            case 6:
              this.logger.log(LogLevel.Debug, "handled response context \n", response);
              return [2, Promise.resolve(response)];
          }
        });
      });
    };
    Request2.prototype.executeRequest = function(options) {
      var _this = this;
      return new Promise(function(resolve, reject) {
        return __awaiter2(_this, void 0, void 0, function() {
          var error_1, task;
          var _this2 = this;
          return __generator2(this, function(_a) {
            switch (_a.label) {
              case 0:
                this.logger.log(LogLevel.Trace, "execute request -options \n", options);
                options.config = options.config ? __assign(__assign({}, this.config), options.config) : __assign({}, this.config);
                if (this.checkAbout(options.config, reject))
                  return [
                    2
                    /*return*/
                  ];
                _a.label = 1;
              case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, this.handleRequestOptions(options)];
              case 2:
                _a.sent();
                return [3, 4];
              case 3:
                error_1 = _a.sent();
                return [2, reject(__assign({ data: null, header: null, statusCode: -1, options }, error_1))];
              case 4:
                if (this.checkAbout(options.config, reject))
                  return [
                    2
                    /*return*/
                  ];
                this.logger.log(LogLevel.Debug, "fixed options \n", options);
                this.logger.log(LogLevel.Trace, "invoke uni.requestWithCookie");
                task = uni.requestWithCookie({
                  url: options.url,
                  data: options.data,
                  dataType: options.responseType,
                  header: options.headers,
                  method: options.method,
                  responseType: function() {
                    switch (options.responseType) {
                      case "json":
                      case "text":
                        return "text";
                      case "arraybuffer":
                        return "arraybuffer";
                    }
                  }(),
                  success: function(res) {
                    return __awaiter2(_this2, void 0, void 0, function() {
                      var data, header, statusCode, errMsg, responseOptions;
                      var _this3 = this;
                      return __generator2(this, function(_a2) {
                        if (this.checkAbout(options.config, reject))
                          return [
                            2
                            /*return*/
                          ];
                        this.logger.log(LogLevel.Debug, "origin response context \n", res);
                        data = res.data, header = res.header, statusCode = res.statusCode, errMsg = res.errMsg;
                        responseOptions = {
                          data,
                          header,
                          statusCode,
                          options,
                          errMsg
                        };
                        this.handleResponse(responseOptions).then(function(res2) {
                          _this3.logger.log(LogLevel.Debug, "handle response context is success. \n", res2);
                          if (options.config.cookie)
                            options.config.cookie.set(options.url, header);
                          resolve(res2);
                        }).catch(function(res2) {
                          _this3.logger.log(LogLevel.Error, "handle response context is fail. \n ", res2);
                          var httpError = new HttpError(res2.errMsg, res2.statusCode);
                          reject(__assign(__assign({}, res2), httpError));
                        });
                        return [
                          2
                          /*return*/
                        ];
                      });
                    });
                  },
                  fail: function(res) {
                    var responseOptions = null;
                    if (res && /request:fail socket time out timeout/.test(res.errMsg)) {
                      responseOptions = __assign({ data: null, status: -1, errMsg: res.errMsg }, new TimeoutError(res.errMsg));
                    } else {
                      responseOptions = __assign({ data: null, status: -1, errMsg: res.errMsg }, new HttpError(res.errMsg, 500));
                    }
                    _this2.handleResponse(responseOptions).then(function(res2) {
                      _this2.logger.log(LogLevel.Debug, "handle response context is success. \n", res2);
                      if (options.config.cookie)
                        options.config.cookie.set(options.url, {});
                      resolve(res2);
                    }).catch(function(res2) {
                      _this2.logger.log(LogLevel.Error, "handle response context is fail. \n ", res2);
                      var httpError = new HttpError(res2.errMsg, res2.statusCode);
                      reject(__assign(__assign({}, res2), httpError));
                    });
                  }
                });
                task.onHeadersReceived(function() {
                  if (_this2.checkAbout(options.config, reject)) {
                    task.abort();
                    return;
                  }
                });
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      });
    };
    Request2.prototype.checkAbout = function(options, reject) {
      if (options.config && options.config.about) {
        reject({
          data: null,
          header: options.headers,
          statusCode: 412,
          options,
          errMsg: "网络异常"
          // 直接自定义错误了.
        });
        return true;
      } else {
        return false;
      }
    };
    Request2.prototype.get = function(url, data, options) {
      if (data === void 0) {
        data = {};
      }
      this.logger.log(LogLevel.Trace, "invoke request.get()");
      var requestOptions = __assign(__assign({}, function() {
        return options ? options : {};
      }()), {
        method: RequestMethod.GET,
        url,
        data
      });
      return this.executeRequest(requestOptions);
    };
    Request2.prototype.post = function(url, data, options) {
      if (data === void 0) {
        data = {};
      }
      this.logger.log(LogLevel.Trace, "invoke request.post()");
      var requestOptions = __assign(__assign({}, function() {
        return options ? options : {};
      }()), {
        method: RequestMethod.POST,
        url,
        data
      });
      return this.executeRequest(requestOptions);
    };
    Request2.prototype.put = function(url, data, options) {
      if (data === void 0) {
        data = {};
      }
      this.logger.log(LogLevel.Trace, "invoke request.put()");
      var requestOptions = __assign(__assign({}, function() {
        return options ? options : {};
      }()), {
        method: RequestMethod.PUT,
        url,
        data
      });
      return this.executeRequest(requestOptions);
    };
    Request2.prototype.delete = function(url, data, options) {
      if (data === void 0) {
        data = {};
      }
      this.logger.log(LogLevel.Trace, "invoke request.delete()");
      var requestOptions = __assign(__assign({}, function() {
        return options ? options : {};
      }()), {
        method: RequestMethod.DELETE,
        url,
        data
      });
      return this.executeRequest(requestOptions);
    };
    Request2.prototype.all = function(taskQueue) {
      this.logger.log(LogLevel.Trace, "invoke request.all()");
      return Promise.all(taskQueue);
    };
    Request2.prototype.getCookieString = function(url) {
      if (this.config && this.config.cookie) {
        return this.config.cookie.origin(url);
      } else {
        return "";
      }
    };
    Request2.prototype.cookie = function(url, key) {
      if (this.config && this.config.cookie) {
        return this.config.cookie.get(url, key);
      } else {
        return "";
      }
    };
    return Request2;
  }()
);

// ../../../流沙任务系统uniapp/uniapp_flow/node_modules/signalr-for-wx/dist/DefualtRequest.js
var __extends2 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (b2.hasOwnProperty(p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var DefaultRequest = (
  /** @class */
  function(_super) {
    __extends2(DefaultRequest2, _super);
    function DefaultRequest2(config, logger) {
      var _this = _super.call(this) || this;
      _this.logger = logger ? logger : {
        log: function(logLevel, message) {
        }
      };
      _this.setConfig(__assign2({ about: false, forceEnableHttps: false, headers: {}, method: RequestMethod.GET, responseEncoding: ResponseType.JSON, timeout: 2 * 60 * 1e3, transformRequest: [], transformResponse: [] }, config));
      return _this;
    }
    return DefaultRequest2;
  }(Request)
);
var DefualtRequest_default = DefaultRequest;

// ../../../流沙任务系统uniapp/uniapp_flow/node_modules/signalr-for-wx/dist/LongPollingTransport.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator3 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var LongPollingTransport = (
  /** @class */
  function() {
    function LongPollingTransport2(options) {
      this.accessTokenFactory = options.accessTokenFactory ? options.accessTokenFactory : void 0;
      this.logger = options.logger ? options.logger : new NullLogger();
      this.pollAbort = new AbortController();
      this.logMessageContent = options.logMessageContent ? options.logMessageContent : false;
      this.request = options.request ? options.request : new DefualtRequest_default({}, this.logger);
      this.running = false;
      this.onreceive = null;
      this.onclose = null;
    }
    Object.defineProperty(LongPollingTransport2.prototype, "pollAborted", {
      // This is an internal type, not exported from 'index' so this is really just internal.
      get: function() {
        return this.pollAbort.aborted;
      },
      enumerable: true,
      configurable: true
    });
    LongPollingTransport2.prototype.connect = function(options) {
      return __awaiter3(this, void 0, void 0, function() {
        var pollOptions, token, response;
        return __generator3(this, function(_a) {
          switch (_a.label) {
            case 0:
              Arg.isRequired(options, "options");
              Arg.isRequired(options.transferFormat, "transferFormat");
              Arg.isIn(options.transferFormat, TransferFormat, "transferFormat");
              this.url = options.url;
              this.logger.log(LogLevel.Trace, "(LongPolling transport) Connecting.");
              pollOptions = {
                config: {
                  // 中断信号
                  about: this.pollAbort.signal.aborted,
                  timeout: 120 * 1e3
                  // 超时时间 2 min
                },
                // origin header 头
                headers: {}
              };
              if (options.transferFormat === TransferFormat.Binary) {
                pollOptions.responseType = ResponseType.ARRAY_BUFFER;
              }
              return [4, this.getAccessToken()];
            case 1:
              token = _a.sent();
              this.updateHeaderToken(pollOptions, token);
              this.logger.log(LogLevel.Trace, "(LongPolling transport) polling: [url]" + this.url);
              return [4, this.request.get(this.url, {
                _: Date.now()
              }, pollOptions)];
            case 2:
              response = _a.sent();
              if (response.statusCode !== 200) {
                this.logger.log(LogLevel.Error, "(LongPolling transport) Unexpected response code: " + response.statusCode + ".");
                this.closeError = new HttpError(response.errMsg || "", response.statusCode);
                this.running = false;
              } else {
                this.running = true;
              }
              this.receiving = this.poll(this.url, pollOptions);
              return [2, Promise.resolve({
                errMsg: "connect success"
              })];
          }
        });
      });
    };
    LongPollingTransport2.prototype.getAccessToken = function() {
      return __awaiter3(this, void 0, void 0, function() {
        return __generator3(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (!this.accessTokenFactory)
                return [3, 2];
              return [4, this.accessTokenFactory()];
            case 1:
              return [2, _a.sent()];
            case 2:
              return [2, null];
          }
        });
      });
    };
    LongPollingTransport2.prototype.updateHeaderToken = function(request, token) {
      if (!request.headers) {
        request.headers = {};
      }
      if (token) {
        request.headers["Authorization"] = "Bearer " + token;
        return;
      }
      if (request.headers["Authorization"]) {
        delete request.headers["Authorization"];
      }
    };
    LongPollingTransport2.prototype.poll = function(url, pollOptions) {
      return __awaiter3(this, void 0, void 0, function() {
        var token, pollUrl, response, e_1;
        return __generator3(this, function(_a) {
          switch (_a.label) {
            case 0:
              _a.trys.push([0, , 8, 9]);
              _a.label = 1;
            case 1:
              if (!this.running)
                return [3, 7];
              return [4, this.getAccessToken()];
            case 2:
              token = _a.sent();
              this.updateHeaderToken(pollOptions, token);
              _a.label = 3;
            case 3:
              _a.trys.push([3, 5, , 6]);
              pollUrl = url + "&_=" + Date.now();
              this.logger.log(LogLevel.Trace, "(LongPolling transport) polling: " + pollUrl + ".  - (fy:长轮询传输 - polling)");
              return [4, this.request.get(this.url, {
                _: Date.now()
              }, pollOptions)];
            case 4:
              response = _a.sent();
              if (response.statusCode === 204) {
                this.logger.log(LogLevel.Information, "(LongPolling transport) Poll terminated by server. - (fy:长轮询传输 - 由服务器终止轮询。)");
                this.running = false;
              } else if (response.statusCode !== 200) {
                this.logger.log(LogLevel.Error, "(LongPolling transport) Unexpected response code: " + response.statusCode + ".  - (fy:长轮询传输 - 意外的响应代码)");
                this.closeError = new HttpError(response.errMsg || "", response.statusCode);
                this.running = false;
              } else {
                if (response.data) {
                  this.logger.log(LogLevel.Trace, "(LongPolling transport) data received. " + getDataDetail(response.data, this.logMessageContent) + ".");
                  if (this.onreceive) {
                    this.onreceive(response.data);
                  }
                } else {
                  this.logger.log(LogLevel.Trace, "(LongPolling transport) Poll timed out, reissuing.");
                }
              }
              return [3, 6];
            case 5:
              e_1 = _a.sent();
              if (!this.running) {
                this.logger.log(LogLevel.Trace, "(LongPolling transport) Poll errored after shutdown: " + e_1.message);
              } else {
                if (e_1 instanceof TimeoutError) {
                  this.logger.log(LogLevel.Trace, "(LongPolling transport) Poll timed out, reissuing.  - (fy:长轮询传输 - 请求超时)");
                } else {
                  this.closeError = e_1;
                  this.running = false;
                }
              }
              return [3, 6];
            case 6:
              return [3, 1];
            case 7:
              return [3, 9];
            case 8:
              this.logger.log(LogLevel.Trace, "(LongPolling transport) Polling complete.   - (fy:长轮询传输 - 请求完成)");
              if (!this.pollAborted) {
                this.raiseOnClose();
              }
              return [
                7
                /*endfinally*/
              ];
            case 9:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    LongPollingTransport2.prototype.send = function(data) {
      return __awaiter3(this, void 0, void 0, function() {
        return __generator3(this, function(_a) {
          if (!this.running) {
            return [2, Promise.reject(new Error("Cannot send until the transport is connected"))];
          }
          return [2, sendMessage(this.logger, "LongPolling", this.request, this.url, this.accessTokenFactory, data, this.logMessageContent)];
        });
      });
    };
    LongPollingTransport2.prototype.stop = function() {
      return __awaiter3(this, void 0, void 0, function() {
        var deleteOptions, token, e_2;
        return __generator3(this, function(_a) {
          switch (_a.label) {
            case 0:
              this.logger.log(LogLevel.Trace, "(LongPolling transport) Stopping polling.");
              this.running = false;
              this.pollAbort.abort();
              _a.label = 1;
            case 1:
              _a.trys.push([1, 5, 6, 7]);
              return [4, this.receiving];
            case 2:
              _a.sent();
              this.logger.log(LogLevel.Trace, "(LongPolling transport) sending DELETE request to " + this.url + ".");
              deleteOptions = {
                headers: {}
              };
              return [4, this.getAccessToken()];
            case 3:
              token = _a.sent();
              this.updateHeaderToken(deleteOptions, token);
              return [4, this.request.delete(this.url, {}, deleteOptions)];
            case 4:
              _a.sent();
              this.logger.log(LogLevel.Trace, "(LongPolling transport) DELETE request sent.");
              return [2, Promise.resolve({
                errMsg: "stop success"
              })];
            case 5:
              e_2 = _a.sent();
              this.logger.log(LogLevel.Error, "(LongPolling transport) Stop error.", e_2);
              return [2, Promise.reject({
                errMsg: "stop fail"
              })];
            case 6:
              this.logger.log(LogLevel.Trace, "(LongPolling transport) Stop finished.");
              this.raiseOnClose();
              return [
                7
                /*endfinally*/
              ];
            case 7:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    LongPollingTransport2.prototype.raiseOnClose = function() {
      if (this.onclose) {
        var logMessage = "(LongPolling transport) Firing onclose event.";
        if (this.closeError) {
          logMessage += " Error: " + this.closeError;
        }
        this.logger.log(LogLevel.Trace, logMessage);
        this.onclose(this.closeError);
      }
    };
    return LongPollingTransport2;
  }()
);

// ../../../流沙任务系统uniapp/uniapp_flow/node_modules/signalr-for-wx/dist/Polyfills.js
var WxSocketReadyState;
(function(WxSocketReadyState2) {
  WxSocketReadyState2[WxSocketReadyState2["CONNECTING"] = 0] = "CONNECTING";
  WxSocketReadyState2[WxSocketReadyState2["OPEN"] = 1] = "OPEN";
  WxSocketReadyState2[WxSocketReadyState2["CLOSING"] = 2] = "CLOSING";
  WxSocketReadyState2[WxSocketReadyState2["CLOSED"] = 3] = "CLOSED";
})(WxSocketReadyState || (WxSocketReadyState = {}));

// ../../../流沙任务系统uniapp/uniapp_flow/node_modules/signalr-for-wx/dist/WechatVersionDiff.js
var isVersionSupport = function(minimumVersion) {
  var compareVersion = function(v1, v2) {
    v1 = v1.split(".");
    v2 = v2.split(".");
    var len = Math.max(v1.length, v2.length);
    while (v1.length < len) {
      v1.push("0");
    }
    while (v2.length < len) {
      v2.push("0");
    }
    for (var i = 0; i < len; i++) {
      var num1 = parseInt(v1[i]);
      var num2 = parseInt(v2[i]);
      if (num1 > num2) {
        return 1;
      } else if (num1 < num2) {
        return -1;
      }
    }
    return 0;
  };
  var SDKVersion = uni.getSystemInfoSync().SDKVersion;
  return compareVersion(SDKVersion, minimumVersion) >= 0;
};

// ../../../流沙任务系统uniapp/uniapp_flow/node_modules/signalr-for-wx/dist/WxSocketTransport.js
var __assign3 = function() {
  __assign3 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign3.apply(this, arguments);
};
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator4 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var WxSocketTransport = (
  /** @class */
  function() {
    function WxSocketTransport2(options) {
      this.readyState = WxSocketReadyState.CONNECTING;
      this.logger = options.logger;
      this.accessTokenFactory = options.accessTokenFactory;
      this.socketUrlFactory = options.socketUrlFactory;
      this.logMessageContent = options.logMessageContent;
      this.onreceive = null;
      this.onclose = null;
      this.allowReplaceSocket = options.allowReplaceSocket;
      this.timeout = options.timeout ? options.timeout : 60 * 1e3;
      this.delayTime = options.delayTime ? options.delayTime : 100;
      if (options.enableMessageQueue) {
        this.enableMessageQueue = true;
        this.messageQueue = [];
      } else {
        this.enableMessageQueue = false;
      }
      if (options.reconnect) {
        this.reconnect = {
          enable: options.reconnect.enable == true ? true : false,
          max: options.reconnect.max ? options.reconnect.max : 3,
          val: 0
        };
      } else {
        this.reconnect = {
          enable: false,
          max: 3,
          val: 0
        };
      }
    }
    WxSocketTransport2.prototype.connect = function(options) {
      return __awaiter4(this, void 0, void 0, function() {
        var replacedUrl, token;
        var _this = this;
        return __generator4(this, function(_a) {
          switch (_a.label) {
            case 0:
              Arg.isRequired(options, "options");
              Arg.validationUrlIsSupportByWechat(options.url);
              this.connectOptions = options;
              this.logger.log(LogLevel.Trace, "(WebSockets transport) Connecting.");
              if (!this.socketUrlFactory)
                return [3, 2];
              return [4, this.socketUrlFactory(options.url)];
            case 1:
              replacedUrl = _a.sent();
              if (replacedUrl) {
                options.url = replacedUrl;
              }
              return [3, 4];
            case 2:
              if (!this.accessTokenFactory)
                return [3, 4];
              return [4, this.accessTokenFactory()];
            case 3:
              token = _a.sent();
              this.logger.log(LogLevel.Debug, "getted token:", token);
              if (token) {
                options.url += (options.url.indexOf("?") < 0 ? "?" : "&") + ("access_token=" + encodeURIComponent(token));
              }
              _a.label = 4;
            case 4:
              return [2, new Promise(function(resolve, reject) {
                options.url = options.url.replace(/^http/, "ws");
                var socketTask;
                var supportCount = isVersionSupport("1.7.0") ? 5 : 1;
                if (supportCount <= WxSocketTransport2.count && !_this.allowReplaceSocket) {
                  reject({
                    errMsg: "Maximum connections|" + WxSocketTransport2.count
                  });
                  return;
                } else if (WxSocketTransport2.count == 5) {
                  reject({
                    errMsg: "Maximum connections|" + WxSocketTransport2.count
                  });
                  return;
                }
                if (!socketTask) {
                  socketTask = uni.connectSocket(__assign3({
                    // 传入 两个默认的 回调,当然也可以在 options 里面覆盖 使用自定义回调.
                    success: function(res) {
                      _this.logger.log(LogLevel.Debug, "uni.connectSocket():success");
                    },
                    fail: function(res) {
                      _this.logger.log(LogLevel.Debug, "uni.connectSocket():fail");
                      reject(res);
                    }
                  }, options));
                }
                socketTask.onOpen(function(result) {
                  return __awaiter4(_this, void 0, void 0, function() {
                    var _i, _a2, msg;
                    return __generator4(this, function(_b) {
                      switch (_b.label) {
                        case 0:
                          this.logger.log(LogLevel.Information, "websocket连接建立 " + (this.logMessageContent ? "wx api:[" + options.url + "]" : ""));
                          this.logger.log(LogLevel.Debug, "uni.connectSocket success message:", result);
                          WxSocketTransport2.count += 1;
                          this.readyState = WxSocketReadyState.OPEN;
                          this.socketTask = socketTask;
                          return [4, resolve()];
                        case 1:
                          _b.sent();
                          if (!(this.enableMessageQueue && this.messageQueue.length > 0))
                            return [3, 5];
                          _i = 0, _a2 = this.messageQueue;
                          _b.label = 2;
                        case 2:
                          if (!(_i < _a2.length))
                            return [3, 5];
                          msg = _a2[_i];
                          this.logger.log(LogLevel.Debug, "推送离线消息", this.logMessageContent ? msg : "");
                          return [4, this.send(msg)];
                        case 3:
                          _b.sent();
                          _b.label = 4;
                        case 4:
                          _i++;
                          return [3, 2];
                        case 5:
                          return [
                            2
                            /*return*/
                          ];
                      }
                    });
                  });
                });
                socketTask.onError(function(res) {
                  _this.readyState = WxSocketReadyState.CLOSED;
                  reject(res);
                });
                socketTask.onMessage(function(res) {
                  _this.logger.log(LogLevel.Trace, "(WebSockets transport) data received.", getDataDetail(res.data, _this.logMessageContent));
                  if (_this.onreceive) {
                    _this.onreceive(res.data);
                  }
                });
                socketTask.onClose(function(res) {
                  return _this.close(res);
                });
              })];
          }
        });
      });
    };
    WxSocketTransport2.prototype.delay = function() {
      var _this = this;
      return new Promise(function(resolve) {
        var timer = setTimeout(function() {
          clearTimeout(timer);
          resolve();
        }, _this.delayTime);
      });
    };
    WxSocketTransport2.prototype.send = function(data) {
      return __awaiter4(this, void 0, void 0, function() {
        var loop;
        var _this = this;
        return __generator4(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (!(this.socketTask && this.readyState === WxSocketReadyState.OPEN))
                return [3, 1];
              this.logger.log(LogLevel.Trace, "[WxSocket] 推送数据.", getDataDetail(data, this.logMessageContent));
              return [2, new Promise(function(resolve, reject) {
                _this.socketTask.send({
                  data,
                  success: function() {
                    return resolve();
                  },
                  fail: function() {
                    return reject();
                  }
                });
              })];
            case 1:
              if (!this.enableMessageQueue)
                return [3, 5];
              this.messageQueue.push(data);
              loop = 0;
              _a.label = 2;
            case 2:
              if (!(this.socketTask && this.readyState !== WxSocketReadyState.OPEN))
                return [3, 4];
              return [4, this.delay()];
            case 3:
              _a.sent();
              loop += this.delayTime;
              if (loop >= this.timeout) {
                return [2, Promise.reject({
                  errMsg: "WebSocket connect timeout."
                })];
              }
              return [3, 2];
            case 4:
              return [2, this.send(data)];
            case 5:
              return [2, Promise.reject({
                errMsg: "WebSocket is not in the OPEN state"
              })];
          }
        });
      });
    };
    WxSocketTransport2.prototype.stop = function(msg) {
      var _this = this;
      return new Promise(function(resolve, reject) {
        if (_this.socketTask) {
          _this.socketTask.close({
            code: 1e3,
            reason: "stop socket",
            success: function(res) {
              return resolve(msg || res);
            },
            fail: function(res) {
              return reject(res);
            }
          });
        }
      });
    };
    WxSocketTransport2.prototype.close = function(res) {
      this.logger.log(LogLevel.Trace, "(WebSockets transport) socket closed.");
      WxSocketTransport2.count = WxSocketTransport2.count > 0 ? WxSocketTransport2.count - 1 : 0;
      if (this.onclose) {
        if (res && res.code !== 1e3) {
          this.onclose(new Error("WebSocket closed with status code: " + res.code + " (" + res.reason + ")."));
        } else {
          this.onclose();
        }
      }
    };
    WxSocketTransport2.count = 0;
    return WxSocketTransport2;
  }()
);

// ../../../流沙任务系统uniapp/uniapp_flow/node_modules/signalr-for-wx/dist/HttpConnection.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator5 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var MAX_REDIRECTS = 100;
var WxSocketModule = WxSocketTransport;
var LongPollingModule = LongPollingTransport;
var HttpConnection = (
  /** @class */
  function() {
    function HttpConnection2(url, options) {
      if (options === void 0) {
        options = {};
      }
      this.features = {};
      Arg.isRequired(url, "url");
      this.logger = createLogger(options.logger);
      options = options || {};
      this.baseUrl = options.resolveUrl ? options.resolveUrl(url) : this.resolveUrl(url);
      options.logMessageContent = options.logMessageContent || false;
      if (!options.WxSocket && wx) {
        options.WxSocket = WxSocketModule;
      }
      if (!options.LongPolling) {
        options.LongPolling = LongPollingModule;
      }
      this.request = options.request || new DefualtRequest_default({}, this.logger);
      this.connectionState = 2;
      this.options = options;
      this.onreceive = null;
      this.onclose = null;
    }
    HttpConnection2.prototype.start = function(transferFormat) {
      transferFormat = transferFormat || TransferFormat.Binary;
      Arg.isIn(transferFormat, TransferFormat, "transferFormat");
      this.logger.log(LogLevel.Debug, "Starting connection with transfer format '" + TransferFormat[transferFormat] + "'.", TransferFormat);
      if (this.connectionState !== 2) {
        return Promise.reject(new Error("Cannot start a connection that is not in the 'Disconnected' state. state is " + this.connectionState));
      }
      this.connectionState = 0;
      this.startPromise = this.startInternal(transferFormat);
      return this.startPromise;
    };
    HttpConnection2.prototype.send = function(data) {
      if (this.connectionState !== 1) {
        throw new Error("Cannot send data if the connection is not in the 'Connected' State.");
      }
      return this.transport.send(data);
    };
    HttpConnection2.prototype.stop = function(error) {
      return __awaiter5(this, void 0, void 0, function() {
        var e_1;
        return __generator5(this, function(_a) {
          switch (_a.label) {
            case 0:
              this.connectionState = 2;
              this.stopError = error;
              _a.label = 1;
            case 1:
              _a.trys.push([1, 3, , 4]);
              return [4, this.startPromise];
            case 2:
              _a.sent();
              return [3, 4];
            case 3:
              e_1 = _a.sent();
              return [3, 4];
            case 4:
              if (!this.transport)
                return [3, 6];
              return [4, this.transport.stop()];
            case 5:
              _a.sent();
              this.transport = void 0;
              _a.label = 6;
            case 6:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    HttpConnection2.prototype.startInternal = function(transferFormat) {
      return __awaiter5(this, void 0, void 0, function() {
        var url, negotiateResponse, redirects, _loop_1, this_1, state_1, e_2;
        var _this = this;
        return __generator5(this, function(_a) {
          switch (_a.label) {
            case 0:
              url = this.baseUrl;
              this.accessTokenFactory = this.options.accessTokenFactory;
              this.socketUrlFactory = this.options.socketUrlFactory;
              _a.label = 1;
            case 1:
              _a.trys.push([1, 12, , 13]);
              if (!this.options.skipNegotiation)
                return [3, 5];
              if (!(this.options.transport === HttpTransportType.WebSockets))
                return [3, 3];
              this.transport = this.constructTransport(HttpTransportType.WebSockets);
              return [4, this.transport.connect({
                url,
                header: {},
                protocols: [],
                tcpNoDelay: true,
                transferFormat
              })];
            case 2:
              _a.sent();
              return [3, 4];
            case 3:
              throw Error("Negotiation can only be skipped when using the WxSocket transport directly.");
            case 4:
              return [3, 11];
            case 5:
              negotiateResponse = null;
              redirects = 0;
              _loop_1 = function() {
                var accessToken_1;
                return __generator5(this, function(_a2) {
                  switch (_a2.label) {
                    case 0:
                      return [4, this_1.getNegotiationResponse(url)];
                    case 1:
                      negotiateResponse = _a2.sent();
                      if (this_1.connectionState === 2) {
                        return [2, { value: void 0 }];
                      }
                      if (negotiateResponse.error) {
                        throw Error(negotiateResponse.error);
                      }
                      if (negotiateResponse.ProtocolVersion) {
                        throw Error("检测到尝试连接到一个 非 ASP.NET Core 服务器。此客户端仅支持连接到ASP.NET Core 服务器。. See https://aka.ms/signalr-core-differences for details.");
                      }
                      if (negotiateResponse.url) {
                        url = negotiateResponse.url;
                      }
                      if (negotiateResponse.accessToken) {
                        accessToken_1 = negotiateResponse.accessToken;
                        this_1.accessTokenFactory = function() {
                          return accessToken_1;
                        };
                      }
                      redirects++;
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              };
              this_1 = this;
              _a.label = 6;
            case 6:
              return [5, _loop_1()];
            case 7:
              state_1 = _a.sent();
              if (typeof state_1 === "object")
                return [2, state_1.value];
              _a.label = 8;
            case 8:
              if (negotiateResponse.url && redirects < MAX_REDIRECTS)
                return [3, 6];
              _a.label = 9;
            case 9:
              if (redirects === MAX_REDIRECTS && negotiateResponse.url) {
                throw Error("Negotiate redirection limit exceeded. -fy : 超出协商重定向限制");
              }
              return [4, this.createTransport(url, this.options.transport, negotiateResponse, transferFormat)];
            case 10:
              _a.sent();
              _a.label = 11;
            case 11:
              if (this.transport instanceof LongPollingTransport) {
                this.features.inherentKeepAlive = true;
              }
              this.transport.onreceive = this.onreceive;
              this.transport.onclose = function(e) {
                return _this.stopConnection(e);
              };
              this.changeState(
                0,
                1
                /* Connected */
              );
              return [
                2
                /*return*/
              ];
            case 12:
              e_2 = _a.sent();
              this.logger.log(LogLevel.Error, "Failed to start the connection: ", e_2);
              this.connectionState = 2;
              this.transport = void 0;
              throw e_2;
            case 13:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    HttpConnection2.prototype.getNegotiationResponse = function(url) {
      return __awaiter5(this, void 0, void 0, function() {
        var headers, token, negotiateUrl, response, e_3;
        var _a;
        return __generator5(this, function(_b) {
          switch (_b.label) {
            case 0:
              if (!this.accessTokenFactory)
                return [3, 2];
              return [4, this.accessTokenFactory()];
            case 1:
              token = _b.sent();
              if (token) {
                headers = (_a = {}, _a["Authorization"] = "Bearer " + token, _a);
              }
              _b.label = 2;
            case 2:
              negotiateUrl = this.resolveNegotiateUrl(url);
              this.logger.log(LogLevel.Debug, "Sending negotiation request: " + negotiateUrl + ".");
              _b.label = 3;
            case 3:
              _b.trys.push([3, 5, , 6]);
              return [4, this.request.post(negotiateUrl, {}, {
                headers,
                responseType: ResponseType.TEXT
              })];
            case 4:
              response = _b.sent();
              if (response.statusCode !== 200) {
                throw Error("Unexpected status code returned from negotiate " + response.statusCode);
              }
              return [2, JSON.parse(response.data)];
            case 5:
              e_3 = _b.sent();
              this.logger.log(LogLevel.Error, "Failed to complete negotiation with the server: ", e_3);
              throw e_3;
            case 6:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    HttpConnection2.prototype.createConnectUrl = function(url, connectionId) {
      if (!connectionId) {
        return url;
      }
      return url + (url.indexOf("?") === -1 ? "?" : "&") + ("id=" + connectionId);
    };
    HttpConnection2.prototype.createTransport = function(url, requestedTransport, negotiateResponse, requestedTransferFormat) {
      return __awaiter5(this, void 0, void 0, function() {
        var connectUrl, transports, _i, transports_1, endpoint, transport, ex_1;
        return __generator5(this, function(_a) {
          switch (_a.label) {
            case 0:
              connectUrl = this.createConnectUrl(url, negotiateResponse.connectionId);
              if (!this.isITransport(requestedTransport))
                return [3, 2];
              this.logger.log(LogLevel.Debug, "Connection was provided an instance of ITransport, using that directly.");
              this.transport = requestedTransport;
              return [4, this.transport.connect({
                url: connectUrl,
                transferFormat: requestedTransferFormat
              })];
            case 1:
              _a.sent();
              this.changeState(
                0,
                1
                /* Connected */
              );
              return [
                2
                /*return*/
              ];
            case 2:
              transports = negotiateResponse.availableTransports || [];
              _i = 0, transports_1 = transports;
              _a.label = 3;
            case 3:
              if (!(_i < transports_1.length))
                return [3, 9];
              endpoint = transports_1[_i];
              this.connectionState = 0;
              transport = this.resolveTransport(endpoint, requestedTransport, requestedTransferFormat);
              if (!(typeof transport === "number"))
                return [3, 8];
              this.transport = this.constructTransport(transport);
              if (!!negotiateResponse.connectionId)
                return [3, 5];
              return [4, this.getNegotiationResponse(url)];
            case 4:
              negotiateResponse = _a.sent();
              connectUrl = this.createConnectUrl(url, negotiateResponse.connectionId);
              _a.label = 5;
            case 5:
              _a.trys.push([5, 7, , 8]);
              return [4, this.transport.connect({
                url: connectUrl,
                transferFormat: requestedTransferFormat
              })];
            case 6:
              _a.sent();
              this.changeState(
                0,
                1
                /* Connected */
              );
              return [
                2
                /*return*/
              ];
            case 7:
              ex_1 = _a.sent();
              this.logger.log(LogLevel.Error, "Failed to start the transport '" + HttpTransportType[transport] + "':", ex_1);
              this.connectionState = 2;
              negotiateResponse.connectionId = void 0;
              return [3, 8];
            case 8:
              _i++;
              return [3, 3];
            case 9:
              throw new Error("Unable to initialize any of the available transports.");
          }
        });
      });
    };
    HttpConnection2.prototype.constructTransport = function(transport) {
      var _a = this.options, WxSocket = _a.WxSocket, LongPolling = _a.LongPolling, wxSocketTransportOptions = _a.wxSocketTransportOptions, longPollingTransportOptions = _a.longPollingTransportOptions;
      switch (transport) {
        case HttpTransportType.WebSockets:
          if (WxSocket instanceof WxSocketTransport) {
            return WxSocket;
          } else {
            return new WxSocket(wxSocketTransportOptions ? wxSocketTransportOptions : {
              // token 工厂
              accessTokenFactory: this.accessTokenFactory,
              // socket 单独实现一个socket url factory(用于后端改了 accecc_token 参数名的场景)
              socketUrlFactory: this.socketUrlFactory,
              // logger
              logger: this.logger,
              logMessageContent: this.options.logMessageContent || false,
              /** 是否允许替换socket连接
               *
               * 小程序 版本 < 1.7.0 时, 最多允许存在一个socket连接, 此参数用于是否允许在这个情况下,替换这个打开的socket
               */
              allowReplaceSocket: true,
              /** 是否启用消息队列缓存连接建立前消息,并在建立连接后发送 */
              enableMessageQueue: this.options.enableMessageQueue == void 0 ? true : this.options.enableMessageQueue,
              /** 重连设置 */
              reconnect: {
                enable: true,
                max: 3
              }
            });
          }
        case HttpTransportType.LongPolling:
          if (LongPolling instanceof LongPollingTransport) {
            return LongPolling;
          } else {
            return new LongPolling(longPollingTransportOptions ? longPollingTransportOptions : {
              request: this.request,
              accessTokenFactory: this.accessTokenFactory,
              logger: this.logger,
              logMessageContent: this.options.logMessageContent || false
            });
          }
        default:
          throw new Error("Unknown transport: " + transport + ".");
      }
    };
    HttpConnection2.prototype.resolveTransport = function(endpoint, requestedTransport, requestedTransferFormat) {
      var transport = HttpTransportType[endpoint.transport];
      if (transport === null || transport === void 0) {
        this.logger.log(LogLevel.Debug, "Skipping transport '" + endpoint.transport + "' because it is not supported by this client.");
      } else {
        var transferFormats = endpoint.transferFormats.map(function(s) {
          return TransferFormat[s];
        });
        if (transportMatches(requestedTransport, transport)) {
          if (transferFormats.indexOf(requestedTransferFormat) >= 0) {
            if (transport === HttpTransportType.WebSockets && !this.options.WxSocket) {
              this.logger.log(LogLevel.Debug, "Skipping transport '" + HttpTransportType[transport] + "' because it is not supported in your environment.'");
            } else {
              this.logger.log(LogLevel.Debug, "Selecting transport '" + HttpTransportType[transport] + "'.");
              return transport;
            }
          } else {
            this.logger.log(LogLevel.Debug, "Skipping transport '" + HttpTransportType[transport] + "' because it does not support the requested transfer format '" + TransferFormat[requestedTransferFormat] + "'.");
          }
        } else {
          this.logger.log(LogLevel.Debug, "Skipping transport '" + HttpTransportType[transport] + "' because it was disabled by the client.");
        }
      }
      return null;
    };
    HttpConnection2.prototype.isITransport = function(transport) {
      return transport && typeof transport === "object" && "connect" in transport;
    };
    HttpConnection2.prototype.changeState = function(from, to) {
      if (this.connectionState === from) {
        this.connectionState = to;
        return true;
      }
      return false;
    };
    HttpConnection2.prototype.stopConnection = function(error) {
      this.transport = void 0;
      error = this.stopError || error;
      if (error) {
        this.logger.log(LogLevel.Error, "Connection disconnected with error '" + error + "'.");
      } else {
        this.logger.log(LogLevel.Information, "Connection disconnected.");
      }
      this.connectionState = 2;
      if (this.onclose) {
        this.onclose(error);
      }
    };
    HttpConnection2.prototype.resolveUrl = function(url) {
      if (url.lastIndexOf("https://", 0) === 0 || url.lastIndexOf("http://", 0) === 0) {
        return url;
      } else {
        throw new Error("HttpConnection. 解析url错误,小程序内需要传入全路径 ->link: " + url);
      }
    };
    HttpConnection2.prototype.resolveNegotiateUrl = function(url) {
      var index = url.indexOf("?");
      var negotiateUrl = url.substring(0, index === -1 ? url.length : index);
      if (negotiateUrl[negotiateUrl.length - 1] !== "/") {
        negotiateUrl += "/";
      }
      negotiateUrl += "negotiate";
      negotiateUrl += index === -1 ? "?negotiateVersion=1" : url.substring(index) + "&negotiateVersion=1";
      return negotiateUrl;
    };
    return HttpConnection2;
  }()
);
function transportMatches(requestedTransport, actualTransport) {
  return !requestedTransport || (actualTransport & requestedTransport) !== 0;
}

// ../../../流沙任务系统uniapp/uniapp_flow/node_modules/signalr-for-wx/dist/HandshakeProtocol.js
var HandshakeProtocol = (
  /** @class */
  function() {
    function HandshakeProtocol2() {
    }
    HandshakeProtocol2.prototype.writeHandshakeRequest = function(handshakeRequest) {
      return TextMessageFormat.write(JSON.stringify(handshakeRequest));
    };
    HandshakeProtocol2.prototype.parseHandshakeResponse = function(data) {
      var responseMessage;
      var messageData;
      var remainingData;
      if (isArrayBuffer(data)) {
        var binaryData = new Uint8Array(data);
        var separatorIndex = binaryData.indexOf(TextMessageFormat.RecordSeparatorCode);
        if (separatorIndex === -1) {
          throw new Error("Message is incomplete.");
        }
        var responseLength = separatorIndex + 1;
        messageData = String.fromCharCode.apply(null, binaryData.slice(0, responseLength));
        remainingData = binaryData.byteLength > responseLength ? binaryData.slice(responseLength).buffer : null;
      } else {
        var textData = data;
        var separatorIndex = textData.indexOf(TextMessageFormat.RecordSeparator);
        if (separatorIndex === -1) {
          throw new Error("Message is incomplete.");
        }
        var responseLength = separatorIndex + 1;
        messageData = textData.substring(0, responseLength);
        remainingData = textData.length > responseLength ? textData.substring(responseLength) : null;
      }
      var messages = TextMessageFormat.parse(messageData);
      var response = JSON.parse(messages[0]);
      if (response.type) {
        throw new Error("Expected a handshake response from the server. -(fy: 需要来自服务器的握手响应)");
      }
      responseMessage = response;
      return [remainingData, responseMessage];
    };
    return HandshakeProtocol2;
  }()
);

// ../../../流沙任务系统uniapp/uniapp_flow/node_modules/signalr-for-wx/dist/HubConnection.js
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator6 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var DEFAULT_TIMEOUT_IN_MS = 30 * 1e3;
var DEFAULT_PING_INTERVAL_IN_MS = 15 * 1e3;
var HubConnectionState;
(function(HubConnectionState2) {
  HubConnectionState2[HubConnectionState2["Disconnected"] = 0] = "Disconnected";
  HubConnectionState2[HubConnectionState2["Connected"] = 1] = "Connected";
})(HubConnectionState || (HubConnectionState = {}));
var HubConnection = (
  /** @class */
  function() {
    function HubConnection2(connection, logger, protocol) {
      var _this = this;
      Arg.isRequired(connection, "connection");
      Arg.isRequired(logger, "logger");
      Arg.isRequired(protocol, "protocol");
      this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;
      this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;
      this.logger = logger;
      this.protocol = protocol;
      this.connection = connection;
      this.handshakeProtocol = new HandshakeProtocol();
      this.connection.onreceive = function(data) {
        return _this.processIncomingData(data);
      };
      this.connection.onclose = function(error) {
        return _this.connectionClosed(error);
      };
      this.callbacks = {};
      this.methods = {};
      this.closedCallbacks = [];
      this.id = 0;
      this.receivedHandshakeResponse = false;
      this.connectionState = HubConnectionState.Disconnected;
      this.cachedPingMessage = this.protocol.writeMessage({ type: MessageType.Ping });
    }
    HubConnection2.create = function(connection, logger, protocol) {
      return new HubConnection2(connection, logger, protocol);
    };
    Object.defineProperty(HubConnection2.prototype, "state", {
      /** Indicates the state of the {@link HubConnection} to the server. */
      get: function() {
        return this.connectionState;
      },
      enumerable: true,
      configurable: true
    });
    HubConnection2.prototype.start = function() {
      return __awaiter6(this, void 0, void 0, function() {
        var handshakeRequest, handshakePromise;
        var _this = this;
        return __generator6(this, function(_a) {
          switch (_a.label) {
            case 0:
              handshakeRequest = {
                protocol: this.protocol.name,
                version: this.protocol.version
              };
              this.logger.log(LogLevel.Debug, "Starting HubConnection.");
              this.receivedHandshakeResponse = false;
              handshakePromise = new Promise(function(resolve, reject) {
                _this.handshakeResolver = resolve;
                _this.handshakeRejecter = reject;
              });
              return [4, this.connection.start(this.protocol.transferFormat)];
            case 1:
              _a.sent();
              this.logger.log(LogLevel.Debug, "Sending handshake request.");
              return [4, this.sendMessage(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest))];
            case 2:
              _a.sent();
              this.logger.log(LogLevel.Information, "Using HubProtocol '" + this.protocol.name + "'.", this.protocol);
              this.cleanupTimeout();
              this.resetTimeoutPeriod();
              this.resetKeepAliveInterval();
              return [4, handshakePromise];
            case 3:
              _a.sent();
              this.connectionState = HubConnectionState.Connected;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    HubConnection2.prototype.stop = function() {
      this.logger.log(LogLevel.Debug, "Stopping HubConnection.");
      this.cleanupTimeout();
      this.cleanupPingTimer();
      return this.connection.stop();
    };
    HubConnection2.prototype.stream = function(methodName) {
      var _this = this;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var invocationDescriptor = this.createStreamInvocation(methodName, args);
      var subject = new Subject(function() {
        var cancelInvocation = _this.createCancelInvocation(invocationDescriptor.invocationId);
        var cancelMessage = _this.protocol.writeMessage(cancelInvocation);
        delete _this.callbacks[invocationDescriptor.invocationId];
        return _this.sendMessage(cancelMessage);
      });
      this.callbacks[invocationDescriptor.invocationId] = function(invocationEvent, error) {
        if (error) {
          subject.error(error);
          return;
        } else if (invocationEvent) {
          if (invocationEvent.type === MessageType.Completion) {
            if (invocationEvent.error) {
              subject.error(new Error(invocationEvent.error));
            } else {
              subject.complete();
            }
          } else {
            subject.next(invocationEvent.item);
          }
        }
      };
      var message = this.protocol.writeMessage(invocationDescriptor);
      this.sendMessage(message).catch(function(e) {
        subject.error(e);
        delete _this.callbacks[invocationDescriptor.invocationId];
      });
      return subject;
    };
    HubConnection2.prototype.sendMessage = function(message) {
      this.resetKeepAliveInterval();
      return this.connection.send(message);
    };
    HubConnection2.prototype.send = function(methodName) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var invocationDescriptor = this.createInvocation(methodName, args, true);
      var message = this.protocol.writeMessage(invocationDescriptor);
      return this.sendMessage(message);
    };
    HubConnection2.prototype.invoke = function(methodName) {
      var _this = this;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var invocationDescriptor = this.createInvocation(methodName, args, false);
      var p = new Promise(function(resolve, reject) {
        _this.callbacks[invocationDescriptor.invocationId] = function(invocationEvent, error) {
          if (error) {
            reject(error);
            return;
          } else if (invocationEvent) {
            if (invocationEvent.type === MessageType.Completion) {
              if (invocationEvent.error) {
                reject(new Error(invocationEvent.error));
              } else {
                resolve(invocationEvent.result);
              }
            } else {
              reject(new Error("Unexpected message type: " + invocationEvent.type));
            }
          }
        };
        var message = _this.protocol.writeMessage(invocationDescriptor);
        _this.sendMessage(message).catch(function(e) {
          reject(e);
          delete _this.callbacks[invocationDescriptor.invocationId];
        });
      });
      return p;
    };
    HubConnection2.prototype.on = function(methodName, newMethod, only) {
      if (!methodName || !newMethod) {
        return;
      }
      methodName = methodName.toLowerCase();
      if (only) {
        this.methods[methodName] = [newMethod];
        return;
      }
      if (!this.methods[methodName]) {
        this.methods[methodName] = [];
      }
      if (this.methods[methodName].indexOf(newMethod) !== -1) {
        return;
      }
      this.methods[methodName].push(newMethod);
    };
    HubConnection2.prototype.off = function(methodName, method) {
      if (!methodName) {
        return;
      }
      methodName = methodName.toLowerCase();
      var handlers = this.methods[methodName];
      if (!handlers) {
        return;
      }
      if (method) {
        var removeIdx = handlers.indexOf(method);
        if (removeIdx !== -1) {
          handlers.splice(removeIdx, 1);
          if (handlers.length === 0) {
            delete this.methods[methodName];
          }
        }
      } else {
        delete this.methods[methodName];
      }
    };
    HubConnection2.prototype.onclose = function(callback) {
      if (callback) {
        this.closedCallbacks.push(callback);
      }
    };
    HubConnection2.prototype.onEventNotFound = function(callback) {
      if (callback) {
        this.eventNotFoundCallback = callback;
      }
    };
    HubConnection2.prototype.processIncomingData = function(data) {
      this.cleanupTimeout();
      if (!this.receivedHandshakeResponse) {
        data = this.processHandshakeResponse(data);
        this.receivedHandshakeResponse = true;
      }
      if (data) {
        var messages = this.protocol.parseMessages(data, this.logger);
        for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {
          var message = messages_1[_i];
          switch (message.type) {
            case MessageType.Invocation:
              this.invokeClientMethod(message);
              break;
            case MessageType.StreamItem:
            case MessageType.Completion:
              var callback = this.callbacks[message.invocationId];
              if (callback != null) {
                if (message.type === MessageType.Completion) {
                  delete this.callbacks[message.invocationId];
                }
                callback(message);
              }
              break;
            case MessageType.Ping:
              break;
            case MessageType.Close:
              this.logger.log(LogLevel.Information, "Close message received from server.");
              this.connection.stop(message.error ? new Error("Server returned an error on close: " + message.error) : void 0);
              break;
            default:
              this.logger.log(LogLevel.Warning, "Invalid message type: " + message.type + ".", message);
              break;
          }
        }
      }
      this.resetTimeoutPeriod();
    };
    HubConnection2.prototype.processHandshakeResponse = function(data) {
      var _a;
      var responseMessage;
      var remainingData;
      try {
        _a = this.handshakeProtocol.parseHandshakeResponse(data), remainingData = _a[0], responseMessage = _a[1];
      } catch (e) {
        var message = "Error parsing handshake response: " + e;
        this.logger.log(LogLevel.Error, message);
        var error = new Error(message);
        this.connection.stop(error);
        this.handshakeRejecter(error);
        throw error;
      }
      if (responseMessage.error) {
        var message = "Server returned handshake error: " + responseMessage.error;
        this.logger.log(LogLevel.Error, message);
        this.handshakeRejecter(message);
        this.connection.stop(new Error(message));
        throw new Error(message);
      } else {
        this.logger.log(LogLevel.Debug, "Server handshake complete.");
      }
      this.handshakeResolver();
      return remainingData;
    };
    HubConnection2.prototype.resetKeepAliveInterval = function() {
      var _this = this;
      this.cleanupPingTimer();
      this.pingServerHandle = setTimeout(function() {
        return __awaiter6(_this, void 0, void 0, function() {
          var _a;
          return __generator6(this, function(_b) {
            switch (_b.label) {
              case 0:
                if (!(this.connectionState === HubConnectionState.Connected))
                  return [3, 4];
                _b.label = 1;
              case 1:
                _b.trys.push([1, 3, , 4]);
                return [4, this.sendMessage(this.cachedPingMessage)];
              case 2:
                _b.sent();
                return [3, 4];
              case 3:
                _a = _b.sent();
                this.cleanupPingTimer();
                return [3, 4];
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, this.keepAliveIntervalInMilliseconds);
    };
    HubConnection2.prototype.resetTimeoutPeriod = function() {
      var _this = this;
      if (!this.connection.features || !this.connection.features.inherentKeepAlive) {
        this.timeoutHandle = setTimeout(function() {
          return _this.serverTimeout();
        }, this.serverTimeoutInMilliseconds);
      }
    };
    HubConnection2.prototype.serverTimeout = function() {
      this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."));
    };
    HubConnection2.prototype.invokeClientMethod = function(invocationMessage) {
      var _this = this;
      var methods = this.methods[invocationMessage.target.toLowerCase()];
      if (methods) {
        try {
          methods.forEach(function(m) {
            return m.apply(_this, invocationMessage.arguments);
          });
        } catch (error) {
          console.error(error);
        }
        if (invocationMessage.invocationId) {
          var message = "Server requested a response, which is not supported in this version of the client.";
          this.logger.log(LogLevel.Error, message);
          this.connection.stop(new Error(message));
        }
      } else {
        var message = "No client method with the name '" + invocationMessage.target + "' found.";
        this.logger.log(LogLevel.Warning, message);
        this.logger.log(LogLevel.Information, "Current Event Methods:" + Object.keys(this.methods));
        this.eventNotFound(new EventNotFoundError(invocationMessage, message));
      }
    };
    HubConnection2.prototype.connectionClosed = function(error) {
      var _this = this;
      var callbacks = this.callbacks;
      this.callbacks = {};
      this.connectionState = HubConnectionState.Disconnected;
      if (this.handshakeRejecter) {
        this.handshakeRejecter(error);
      }
      Object.keys(callbacks).forEach(function(key) {
        var callback = callbacks[key];
        callback(null, error ? error : new Error("Invocation canceled due to connection being closed."));
      });
      this.cleanupTimeout();
      this.cleanupPingTimer();
      this.closedCallbacks.forEach(function(c) {
        return c.apply(_this, [error]);
      });
    };
    HubConnection2.prototype.eventNotFound = function(error) {
      return __awaiter6(this, void 0, void 0, function() {
        var r;
        return __generator6(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (!this.eventNotFoundCallback)
                return [3, 2];
              return [4, this.eventNotFoundCallback(error)];
            case 1:
              r = _a.sent();
              if (r === true) {
                this.logger.log(LogLevel.Information, "retry invoke local message callback.");
                this.invokeClientMethod(error.invocationMessage);
              }
              _a.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    HubConnection2.prototype.cleanupPingTimer = function() {
      if (this.pingServerHandle) {
        clearTimeout(this.pingServerHandle);
      }
    };
    HubConnection2.prototype.cleanupTimeout = function() {
      if (this.timeoutHandle) {
        clearTimeout(this.timeoutHandle);
      }
    };
    HubConnection2.prototype.createInvocation = function(methodName, args, nonblocking) {
      if (nonblocking) {
        return {
          arguments: args,
          target: methodName,
          type: MessageType.Invocation
        };
      } else {
        var id = this.id;
        this.id++;
        return {
          arguments: args,
          invocationId: id.toString(),
          target: methodName,
          type: MessageType.Invocation
        };
      }
    };
    HubConnection2.prototype.createStreamInvocation = function(methodName, args) {
      var id = this.id;
      this.id++;
      return {
        arguments: args,
        invocationId: id.toString(),
        target: methodName,
        type: MessageType.StreamInvocation
      };
    };
    HubConnection2.prototype.createCancelInvocation = function(id) {
      return {
        invocationId: id,
        type: MessageType.CancelInvocation
      };
    };
    return HubConnection2;
  }()
);

// ../../../流沙任务系统uniapp/uniapp_flow/node_modules/signalr-for-wx/dist/HubConnectionBuilder.js
var HubConnectionBuilder = (
  /** @class */
  function() {
    function HubConnectionBuilder2() {
    }
    HubConnectionBuilder2.prototype.configureLogging = function(logging) {
      Arg.isRequired(logging, "logging");
      if (isLogger(logging)) {
        this.logger = logging;
      } else {
        this.logger = new ConsoleLogger(logging);
      }
      return this;
    };
    HubConnectionBuilder2.prototype.withUrl = function(url, transportTypeOrOptions) {
      Arg.isRequired(url, "url");
      this.url = url;
      if (typeof transportTypeOrOptions === "object") {
        this.httpConnectionOptions = transportTypeOrOptions;
      } else {
        this.httpConnectionOptions = {
          transport: transportTypeOrOptions
        };
      }
      return this;
    };
    HubConnectionBuilder2.prototype.withHubProtocol = function(protocol) {
      Arg.isRequired(protocol, "protocol");
      this.protocol = protocol;
      return this;
    };
    HubConnectionBuilder2.prototype.build = function() {
      var httpConnectionOptions = this.httpConnectionOptions || {};
      if (httpConnectionOptions.logger === void 0) {
        httpConnectionOptions.logger = this.logger;
      }
      if (!this.url) {
        throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");
      }
      var connection = new HttpConnection(this.url, httpConnectionOptions);
      return HubConnection.create(connection, this.logger || NullLogger.instance, this.protocol || new JsonHubProtocol());
    };
    return HubConnectionBuilder2;
  }()
);
function isLogger(logger) {
  return logger.log !== void 0;
}

// ../../../流沙任务系统uniapp/uniapp_flow/node_modules/signalr-for-wx/dist/index.js
var VERSION = "1.1.6";
export {
  AbortError,
  HttpError,
  HttpTransportType,
  HubConnection,
  HubConnectionBuilder,
  HubConnectionState,
  JsonHubProtocol,
  LogLevel,
  MessageType,
  Request,
  RequestMethod,
  ResponseType,
  TimeoutError,
  TransferFormat,
  VERSION,
  WxSocketTransport,
  isVersionSupport
};
//# sourceMappingURL=signalr-for-wx_dist_index.js.map
