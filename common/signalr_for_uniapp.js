/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/AbortController.ts":
/*!********************************!*\
  !*** ./src/AbortController.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortController: () => (/* binding */ AbortController)\n/* harmony export */ });\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// Rough polyfill of https://developer.mozilla.org/en-US/docs/Web/API/AbortController\n// We don't actually ever use the API being polyfilled, we always use the polyfill because\n// it's a very new API right now.\n// Not exported from index.\n/** @private */\nclass AbortController {\n    constructor() {\n        this._isAborted = false;\n        this.onabort = null;\n    }\n    abort() {\n        if (!this._isAborted) {\n            this._isAborted = true;\n            if (this.onabort) {\n                this.onabort();\n            }\n        }\n    }\n    get signal() {\n        return this;\n    }\n    get aborted() {\n        return this._isAborted;\n    }\n}\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/AbortController.ts?");

/***/ }),

/***/ "./src/AccessTokenHttpClient.ts":
/*!**************************************!*\
  !*** ./src/AccessTokenHttpClient.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AccessTokenHttpClient: () => (/* binding */ AccessTokenHttpClient)\n/* harmony export */ });\n/* harmony import */ var _HeaderNames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HeaderNames */ \"./src/HeaderNames.ts\");\n/* harmony import */ var _HttpClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HttpClient */ \"./src/HttpClient.ts\");\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n/** @private */\nclass AccessTokenHttpClient extends _HttpClient__WEBPACK_IMPORTED_MODULE_1__.HttpClient {\n    constructor(innerClient, accessTokenFactory) {\n        super();\n        this._innerClient = innerClient;\n        this._accessTokenFactory = accessTokenFactory;\n    }\n    send(request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let allowRetry = true;\n            if (this._accessTokenFactory && (!this._accessToken || (request.url && request.url.indexOf(\"/negotiate?\") > 0))) {\n                // don't retry if the request is a negotiate or if we just got a potentially new token from the access token factory\n                allowRetry = false;\n                this._accessToken = yield this._accessTokenFactory();\n            }\n            this._setAuthorizationHeader(request);\n            const response = yield this._innerClient.send(request);\n            if (allowRetry && response.statusCode === 401 && this._accessTokenFactory) {\n                this._accessToken = yield this._accessTokenFactory();\n                this._setAuthorizationHeader(request);\n                return yield this._innerClient.send(request);\n            }\n            return response;\n        });\n    }\n    _setAuthorizationHeader(request) {\n        if (!request.headers) {\n            request.headers = {};\n        }\n        if (this._accessToken) {\n            request.headers[_HeaderNames__WEBPACK_IMPORTED_MODULE_0__.HeaderNames.Authorization] = `Bearer ${this._accessToken}`;\n        }\n        // don't remove the header if there isn't an access token factory, the user manually added the header in this case\n        else if (this._accessTokenFactory) {\n            if (request.headers[_HeaderNames__WEBPACK_IMPORTED_MODULE_0__.HeaderNames.Authorization]) {\n                delete request.headers[_HeaderNames__WEBPACK_IMPORTED_MODULE_0__.HeaderNames.Authorization];\n            }\n        }\n    }\n    getCookieString(url) {\n        return this._innerClient.getCookieString(url);\n    }\n}\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/AccessTokenHttpClient.ts?");

/***/ }),

/***/ "./src/DefaultHttpClient.ts":
/*!**********************************!*\
  !*** ./src/DefaultHttpClient.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultHttpClient: () => (/* binding */ DefaultHttpClient)\n/* harmony export */ });\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors */ \"./src/Errors.ts\");\n/* harmony import */ var _FetchHttpClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FetchHttpClient */ \"./src/FetchHttpClient.ts\");\n/* harmony import */ var _HttpClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HttpClient */ \"./src/HttpClient.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils */ \"./src/Utils.ts\");\n/* harmony import */ var _XhrHttpClient__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./XhrHttpClient */ \"./src/XhrHttpClient.ts\");\n/* harmony import */ var _UniHttpClient__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./UniHttpClient */ \"./src/UniHttpClient.ts\");\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n\n\n\n\n\nclass DefaultHttpClient extends _HttpClient__WEBPACK_IMPORTED_MODULE_2__.HttpClient {\n    /** Creates a new instance of the {@link @microsoft/signalr.DefaultHttpClient}, using the provided {@link @microsoft/signalr.ILogger} to log messages. */\n    constructor(logger) {\n        super();\n        if (typeof wx !== 'undefined') {\n            this._httpClient = new _UniHttpClient__WEBPACK_IMPORTED_MODULE_5__.UniHttpClient(logger);\n        }\n        else if (typeof fetch !== \"undefined\" || _Utils__WEBPACK_IMPORTED_MODULE_3__.Platform.isNode) {\n            this._httpClient = new _FetchHttpClient__WEBPACK_IMPORTED_MODULE_1__.FetchHttpClient(logger);\n        }\n        else if (typeof XMLHttpRequest !== \"undefined\") {\n            this._httpClient = new _XhrHttpClient__WEBPACK_IMPORTED_MODULE_4__.XhrHttpClient(logger);\n        }\n        else {\n            throw new Error(\"No usable HttpClient found.\");\n        }\n    }\n    /** @inheritDoc */\n    send(request) {\n        // Check that abort was not signaled before calling send\n        if (request.abortSignal && request.abortSignal.aborted) {\n            return Promise.reject(new _Errors__WEBPACK_IMPORTED_MODULE_0__.AbortError());\n        }\n        if (!request.method) {\n            return Promise.reject(new Error(\"No method defined.\"));\n        }\n        if (!request.url) {\n            return Promise.reject(new Error(\"No url defined.\"));\n        }\n        return this._httpClient.send(request);\n    }\n    getCookieString(url) {\n        return this._httpClient.getCookieString(url);\n    }\n}\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/DefaultHttpClient.ts?");

/***/ }),

/***/ "./src/DefaultReconnectPolicy.ts":
/*!***************************************!*\
  !*** ./src/DefaultReconnectPolicy.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultReconnectPolicy: () => (/* binding */ DefaultReconnectPolicy)\n/* harmony export */ });\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// 0, 2, 10, 30 second delays before reconnect attempts.\nconst DEFAULT_RETRY_DELAYS_IN_MILLISECONDS = [0, 2000, 10000, 30000, null];\n/** @private */\nclass DefaultReconnectPolicy {\n    constructor(retryDelays) {\n        this._retryDelays = retryDelays !== undefined ? [...retryDelays, null] : DEFAULT_RETRY_DELAYS_IN_MILLISECONDS;\n    }\n    nextRetryDelayInMilliseconds(retryContext) {\n        return this._retryDelays[retryContext.previousRetryCount];\n    }\n}\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/DefaultReconnectPolicy.ts?");

/***/ }),

/***/ "./src/Errors.ts":
/*!***********************!*\
  !*** ./src/Errors.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortError: () => (/* binding */ AbortError),\n/* harmony export */   AggregateErrors: () => (/* binding */ AggregateErrors),\n/* harmony export */   DisabledTransportError: () => (/* binding */ DisabledTransportError),\n/* harmony export */   FailedToNegotiateWithServerError: () => (/* binding */ FailedToNegotiateWithServerError),\n/* harmony export */   FailedToStartTransportError: () => (/* binding */ FailedToStartTransportError),\n/* harmony export */   HttpError: () => (/* binding */ HttpError),\n/* harmony export */   TimeoutError: () => (/* binding */ TimeoutError),\n/* harmony export */   UnsupportedTransportError: () => (/* binding */ UnsupportedTransportError)\n/* harmony export */ });\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n/** Error thrown when an HTTP request fails. */\nclass HttpError extends Error {\n    /** Constructs a new instance of {@link @microsoft/signalr.HttpError}.\n     *\n     * @param {string} errorMessage A descriptive error message.\n     * @param {number} statusCode The HTTP status code represented by this error.\n     */\n    constructor(errorMessage, statusCode) {\n        const trueProto = new.target.prototype;\n        super(`${errorMessage}: Status code '${statusCode}'`);\n        this.statusCode = statusCode;\n        // Workaround issue in Typescript compiler\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\n        this.__proto__ = trueProto;\n    }\n}\n/** Error thrown when a timeout elapses. */\nclass TimeoutError extends Error {\n    /** Constructs a new instance of {@link @microsoft/signalr.TimeoutError}.\n     *\n     * @param {string} errorMessage A descriptive error message.\n     */\n    constructor(errorMessage = \"A timeout occurred.\") {\n        const trueProto = new.target.prototype;\n        super(errorMessage);\n        // Workaround issue in Typescript compiler\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\n        this.__proto__ = trueProto;\n    }\n}\n/** Error thrown when an action is aborted. */\nclass AbortError extends Error {\n    /** Constructs a new instance of {@link AbortError}.\n     *\n     * @param {string} errorMessage A descriptive error message.\n     */\n    constructor(errorMessage = \"An abort occurred.\") {\n        const trueProto = new.target.prototype;\n        super(errorMessage);\n        // Workaround issue in Typescript compiler\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\n        this.__proto__ = trueProto;\n    }\n}\n/** Error thrown when the selected transport is unsupported by the browser. */\n/** @private */\nclass UnsupportedTransportError extends Error {\n    /** Constructs a new instance of {@link @microsoft/signalr.UnsupportedTransportError}.\n     *\n     * @param {string} message A descriptive error message.\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\n     */\n    constructor(message, transport) {\n        const trueProto = new.target.prototype;\n        super(message);\n        this.transport = transport;\n        this.errorType = 'UnsupportedTransportError';\n        // Workaround issue in Typescript compiler\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\n        this.__proto__ = trueProto;\n    }\n}\n/** Error thrown when the selected transport is disabled by the browser. */\n/** @private */\nclass DisabledTransportError extends Error {\n    /** Constructs a new instance of {@link @microsoft/signalr.DisabledTransportError}.\n     *\n     * @param {string} message A descriptive error message.\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\n     */\n    constructor(message, transport) {\n        const trueProto = new.target.prototype;\n        super(message);\n        this.transport = transport;\n        this.errorType = 'DisabledTransportError';\n        // Workaround issue in Typescript compiler\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\n        this.__proto__ = trueProto;\n    }\n}\n/** Error thrown when the selected transport cannot be started. */\n/** @private */\nclass FailedToStartTransportError extends Error {\n    /** Constructs a new instance of {@link @microsoft/signalr.FailedToStartTransportError}.\n     *\n     * @param {string} message A descriptive error message.\n     * @param {HttpTransportType} transport The {@link @microsoft/signalr.HttpTransportType} this error occurred on.\n     */\n    constructor(message, transport) {\n        const trueProto = new.target.prototype;\n        super(message);\n        this.transport = transport;\n        this.errorType = 'FailedToStartTransportError';\n        // Workaround issue in Typescript compiler\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\n        this.__proto__ = trueProto;\n    }\n}\n/** Error thrown when the negotiation with the server failed to complete. */\n/** @private */\nclass FailedToNegotiateWithServerError extends Error {\n    /** Constructs a new instance of {@link @microsoft/signalr.FailedToNegotiateWithServerError}.\n     *\n     * @param {string} message A descriptive error message.\n     */\n    constructor(message) {\n        const trueProto = new.target.prototype;\n        super(message);\n        this.errorType = 'FailedToNegotiateWithServerError';\n        // Workaround issue in Typescript compiler\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\n        this.__proto__ = trueProto;\n    }\n}\n/** Error thrown when multiple errors have occurred. */\n/** @private */\nclass AggregateErrors extends Error {\n    /** Constructs a new instance of {@link @microsoft/signalr.AggregateErrors}.\n     *\n     * @param {string} message A descriptive error message.\n     * @param {Error[]} innerErrors The collection of errors this error is aggregating.\n     */\n    constructor(message, innerErrors) {\n        const trueProto = new.target.prototype;\n        super(message);\n        this.innerErrors = innerErrors;\n        // Workaround issue in Typescript compiler\n        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200\n        this.__proto__ = trueProto;\n    }\n}\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/Errors.ts?");

/***/ }),

/***/ "./src/FetchHttpClient.ts":
/*!********************************!*\
  !*** ./src/FetchHttpClient.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchHttpClient: () => (/* binding */ FetchHttpClient)\n/* harmony export */ });\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors */ \"./src/Errors.ts\");\n/* harmony import */ var _HttpClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HttpClient */ \"./src/HttpClient.ts\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ILogger */ \"./src/ILogger.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils */ \"./src/Utils.ts\");\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\nclass FetchHttpClient extends _HttpClient__WEBPACK_IMPORTED_MODULE_1__.HttpClient {\n    constructor(logger) {\n        super();\n        this._logger = logger;\n        if (typeof fetch === \"undefined\") {\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\n            // @ts-ignore: TS doesn't know about these names\n            const requireFunc =  true ? require : 0;\n            // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\n            this._jar = new (requireFunc(\"tough-cookie\")).CookieJar();\n            this._fetchType = requireFunc(\"node-fetch\");\n            // node-fetch doesn't have a nice API for getting and setting cookies\n            // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\n            this._fetchType = requireFunc(\"fetch-cookie\")(this._fetchType, this._jar);\n        }\n        else {\n            this._fetchType = fetch.bind((0,_Utils__WEBPACK_IMPORTED_MODULE_3__.getGlobalThis)());\n        }\n        if (typeof AbortController === \"undefined\") {\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\n            // @ts-ignore: TS doesn't know about these names\n            const requireFunc =  true ? require : 0;\n            // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\n            this._abortControllerType = requireFunc(\"abort-controller\");\n        }\n        else {\n            this._abortControllerType = AbortController;\n        }\n    }\n    /** @inheritDoc */\n    send(request) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Check that abort was not signaled before calling send\n            if (request.abortSignal && request.abortSignal.aborted) {\n                throw new _Errors__WEBPACK_IMPORTED_MODULE_0__.AbortError();\n            }\n            if (!request.method) {\n                throw new Error(\"No method defined.\");\n            }\n            if (!request.url) {\n                throw new Error(\"No url defined.\");\n            }\n            const abortController = new this._abortControllerType();\n            let error;\n            // Hook our abortSignal into the abort controller\n            if (request.abortSignal) {\n                request.abortSignal.onabort = () => {\n                    abortController.abort();\n                    error = new _Errors__WEBPACK_IMPORTED_MODULE_0__.AbortError();\n                };\n            }\n            // If a timeout has been passed in, setup a timeout to call abort\n            // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout\n            let timeoutId = null;\n            if (request.timeout) {\n                const msTimeout = request.timeout;\n                timeoutId = setTimeout(() => {\n                    abortController.abort();\n                    this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Warning, `Timeout from HTTP request.`);\n                    error = new _Errors__WEBPACK_IMPORTED_MODULE_0__.TimeoutError();\n                }, msTimeout);\n            }\n            if (request.content === \"\") {\n                request.content = undefined;\n            }\n            if (request.content) {\n                // Explicitly setting the Content-Type header for React Native on Android platform.\n                request.headers = request.headers || {};\n                if ((0,_Utils__WEBPACK_IMPORTED_MODULE_3__.isArrayBuffer)(request.content)) {\n                    request.headers[\"Content-Type\"] = \"application/octet-stream\";\n                }\n                else {\n                    request.headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n                }\n            }\n            let response;\n            try {\n                response = yield this._fetchType(request.url, {\n                    body: request.content,\n                    cache: \"no-cache\",\n                    //credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\n                    headers: Object.assign({ \"X-Requested-With\": \"XMLHttpRequest\" }, request.headers),\n                    method: request.method,\n                    mode: \"cors\",\n                    redirect: \"follow\",\n                    signal: abortController.signal,\n                });\n            }\n            catch (e) {\n                if (error) {\n                    throw error;\n                }\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Warning, `Error from HTTP request. ${e}.`);\n                throw e;\n            }\n            finally {\n                if (timeoutId) {\n                    clearTimeout(timeoutId);\n                }\n                if (request.abortSignal) {\n                    request.abortSignal.onabort = null;\n                }\n            }\n            if (!response.ok) {\n                const errorMessage = yield deserializeContent(response, \"text\");\n                throw new _Errors__WEBPACK_IMPORTED_MODULE_0__.HttpError(errorMessage || response.statusText, response.status);\n            }\n            const content = deserializeContent(response, request.responseType);\n            const payload = yield content;\n            return new _HttpClient__WEBPACK_IMPORTED_MODULE_1__.HttpResponse(response.status, response.statusText, payload);\n        });\n    }\n    getCookieString(url) {\n        let cookies = \"\";\n        if (_Utils__WEBPACK_IMPORTED_MODULE_3__.Platform.isNode && this._jar) {\n            // @ts-ignore: unused variable\n            this._jar.getCookies(url, (e, c) => cookies = c.join(\"; \"));\n        }\n        return cookies;\n    }\n}\nfunction deserializeContent(response, responseType) {\n    let content;\n    switch (responseType) {\n        case \"arraybuffer\":\n            content = response.arrayBuffer();\n            break;\n        case \"text\":\n            content = response.text();\n            break;\n        case \"blob\":\n        case \"document\":\n        case \"json\":\n            throw new Error(`${responseType} is not supported.`);\n        default:\n            content = response.text();\n            break;\n    }\n    return content;\n}\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/FetchHttpClient.ts?");

/***/ }),

/***/ "./src/HandshakeProtocol.ts":
/*!**********************************!*\
  !*** ./src/HandshakeProtocol.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HandshakeProtocol: () => (/* binding */ HandshakeProtocol)\n/* harmony export */ });\n/* harmony import */ var _TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextMessageFormat */ \"./src/TextMessageFormat.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ \"./src/Utils.ts\");\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n\n/** @private */\nclass HandshakeProtocol {\n    // Handshake request is always JSON\n    writeHandshakeRequest(handshakeRequest) {\n        return _TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__.TextMessageFormat.write(JSON.stringify(handshakeRequest));\n    }\n    parseHandshakeResponse(data) {\n        let messageData;\n        let remainingData;\n        if ((0,_Utils__WEBPACK_IMPORTED_MODULE_1__.isArrayBuffer)(data)) {\n            // Format is binary but still need to read JSON text from handshake response\n            const binaryData = new Uint8Array(data);\n            const separatorIndex = binaryData.indexOf(_TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__.TextMessageFormat.RecordSeparatorCode);\n            if (separatorIndex === -1) {\n                throw new Error(\"Message is incomplete.\");\n            }\n            // content before separator is handshake response\n            // optional content after is additional messages\n            const responseLength = separatorIndex + 1;\n            messageData = String.fromCharCode.apply(null, Array.prototype.slice.call(binaryData.slice(0, responseLength)));\n            remainingData = (binaryData.byteLength > responseLength) ? binaryData.slice(responseLength).buffer : null;\n        }\n        else {\n            const textData = data;\n            const separatorIndex = textData.indexOf(_TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__.TextMessageFormat.RecordSeparator);\n            if (separatorIndex === -1) {\n                throw new Error(\"Message is incomplete.\");\n            }\n            // content before separator is handshake response\n            // optional content after is additional messages\n            const responseLength = separatorIndex + 1;\n            messageData = textData.substring(0, responseLength);\n            remainingData = (textData.length > responseLength) ? textData.substring(responseLength) : null;\n        }\n        // At this point we should have just the single handshake message\n        const messages = _TextMessageFormat__WEBPACK_IMPORTED_MODULE_0__.TextMessageFormat.parse(messageData);\n        const response = JSON.parse(messages[0]);\n        if (response.type) {\n            throw new Error(\"Expected a handshake response from the server.\");\n        }\n        const responseMessage = response;\n        // multiple messages could have arrived with handshake\n        // return additional data to be parsed as usual, or null if all parsed\n        return [remainingData, responseMessage];\n    }\n}\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/HandshakeProtocol.ts?");

/***/ }),

/***/ "./src/HeaderNames.ts":
/*!****************************!*\
  !*** ./src/HeaderNames.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HeaderNames: () => (/* binding */ HeaderNames)\n/* harmony export */ });\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nclass HeaderNames {\n}\nHeaderNames.Authorization = \"Authorization\";\nHeaderNames.Cookie = \"Cookie\";\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/HeaderNames.ts?");

/***/ }),

/***/ "./src/HttpClient.ts":
/*!***************************!*\
  !*** ./src/HttpClient.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HttpClient: () => (/* binding */ HttpClient),\n/* harmony export */   HttpResponse: () => (/* binding */ HttpResponse)\n/* harmony export */ });\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n/** Represents an HTTP response. */\nclass HttpResponse {\n    constructor(statusCode, statusText, content) {\n        this.statusCode = statusCode;\n        this.statusText = statusText;\n        this.content = content;\n    }\n}\n/** Abstraction over an HTTP client.\n *\n * This class provides an abstraction over an HTTP client so that a different implementation can be provided on different platforms.\n */\nclass HttpClient {\n    get(url, options) {\n        return this.send(Object.assign(Object.assign({}, options), { method: \"GET\", url }));\n    }\n    post(url, options) {\n        return this.send(Object.assign(Object.assign({}, options), { method: \"POST\", url }));\n    }\n    delete(url, options) {\n        return this.send(Object.assign(Object.assign({}, options), { method: \"DELETE\", url }));\n    }\n    /** Gets all cookies that apply to the specified URL.\n     *\n     * @param url The URL that the cookies are valid for.\n     * @returns {string} A string containing all the key-value cookie pairs for the specified URL.\n     */\n    // @ts-ignore\n    getCookieString(url) {\n        return \"\";\n    }\n}\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/HttpClient.ts?");

/***/ }),

/***/ "./src/HttpConnection.ts":
/*!*******************************!*\
  !*** ./src/HttpConnection.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HttpConnection: () => (/* binding */ HttpConnection),\n/* harmony export */   TransportSendQueue: () => (/* binding */ TransportSendQueue)\n/* harmony export */ });\n/* harmony import */ var _AccessTokenHttpClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AccessTokenHttpClient */ \"./src/AccessTokenHttpClient.ts\");\n/* harmony import */ var _DefaultHttpClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DefaultHttpClient */ \"./src/DefaultHttpClient.ts\");\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Errors */ \"./src/Errors.ts\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ILogger */ \"./src/ILogger.ts\");\n/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ITransport */ \"./src/ITransport.ts\");\n/* harmony import */ var _LongPollingTransport__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./LongPollingTransport */ \"./src/LongPollingTransport.ts\");\n/* harmony import */ var _ServerSentEventsTransport__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ServerSentEventsTransport */ \"./src/ServerSentEventsTransport.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Utils */ \"./src/Utils.ts\");\n/* harmony import */ var _WebSocketTransport__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./WebSocketTransport */ \"./src/WebSocketTransport.ts\");\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\n\n\n\nconst MAX_REDIRECTS = 100;\n/** @private */\nclass HttpConnection {\n    constructor(url, options = {}) {\n        this._stopPromiseResolver = () => { };\n        this.features = {};\n        this._negotiateVersion = 1;\n        _Utils__WEBPACK_IMPORTED_MODULE_7__.Arg.isRequired(url, \"url\");\n        this._logger = (0,_Utils__WEBPACK_IMPORTED_MODULE_7__.createLogger)(options.logger);\n        this.baseUrl = this._resolveUrl(url);\n        options = options || {};\n        options.logMessageContent = options.logMessageContent === undefined ? false : options.logMessageContent;\n        if (typeof options.withCredentials === \"boolean\" || options.withCredentials === undefined) {\n            options.withCredentials = options.withCredentials === undefined ? true : options.withCredentials;\n        }\n        else {\n            throw new Error(\"withCredentials option was not a 'boolean' or 'undefined' value\");\n        }\n        options.timeout = options.timeout === undefined ? 100 * 1000 : options.timeout;\n        let socketTaskModule = null;\n        let eventSourceModule = null;\n        if (_Utils__WEBPACK_IMPORTED_MODULE_7__.Platform.isNode && \"function\" !== \"undefined\") {\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\n            // @ts-ignore: TS doesn't know about these names\n            const requireFunc =  true ? require : 0;\n            socketTaskModule = requireFunc(\"ws\");\n            eventSourceModule = requireFunc(\"eventsource\");\n        }\n        if (!_Utils__WEBPACK_IMPORTED_MODULE_7__.Platform.isNode && typeof SocketTaskConstructor !== \"undefined\" && !options.SocketTask) {\n            options.SocketTask = SocketTaskConstructor;\n        }\n        else if (_Utils__WEBPACK_IMPORTED_MODULE_7__.Platform.isNode && !options.SocketTask) {\n            if (socketTaskModule) {\n                options.SocketTask = socketTaskModule;\n            }\n        }\n        if (!_Utils__WEBPACK_IMPORTED_MODULE_7__.Platform.isNode && typeof EventSource !== \"undefined\" && !options.EventSource) {\n            options.EventSource = EventSource;\n        }\n        else if (_Utils__WEBPACK_IMPORTED_MODULE_7__.Platform.isNode && !options.EventSource) {\n            if (typeof eventSourceModule !== \"undefined\") {\n                options.EventSource = eventSourceModule;\n            }\n        }\n        this._httpClient = new _AccessTokenHttpClient__WEBPACK_IMPORTED_MODULE_0__.AccessTokenHttpClient(options.httpClient || new _DefaultHttpClient__WEBPACK_IMPORTED_MODULE_1__.DefaultHttpClient(this._logger), options.accessTokenFactory);\n        this._connectionState = \"Disconnected\" /* ConnectionState.Disconnected */;\n        this._connectionStarted = false;\n        this._options = options;\n        this.onreceive = null;\n        this.onclose = null;\n    }\n    start(transferFormat) {\n        return __awaiter(this, void 0, void 0, function* () {\n            transferFormat = transferFormat || _ITransport__WEBPACK_IMPORTED_MODULE_4__.TransferFormat.Binary;\n            _Utils__WEBPACK_IMPORTED_MODULE_7__.Arg.isIn(transferFormat, _ITransport__WEBPACK_IMPORTED_MODULE_4__.TransferFormat, \"transferFormat\");\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, `Starting connection with transfer format '${_ITransport__WEBPACK_IMPORTED_MODULE_4__.TransferFormat[transferFormat]}'.`);\n            if (this._connectionState !== \"Disconnected\" /* ConnectionState.Disconnected */) {\n                this._connectionState = \"Disconnected\" /* ConnectionState.Disconnected */;\n                return Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"));\n            }\n            this._connectionState = \"Connecting\" /* ConnectionState.Connecting */;\n            this._startInternalPromise = this._startInternal(transferFormat);\n            yield this._startInternalPromise;\n            // The TypeScript compiler thinks that connectionState must be Connecting here. The TypeScript compiler is wrong.\n            if (this._connectionState === \"Disconnecting\" /* ConnectionState.Disconnecting */) {\n                // stop() was called and transitioned the client into the Disconnecting state.\n                const message = \"Failed to start the HttpConnection before stop() was called.\";\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Error, message);\n                // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\n                yield this._stopPromise;\n                return Promise.reject(new _Errors__WEBPACK_IMPORTED_MODULE_2__.AbortError(message));\n            }\n            else if (this._connectionState !== \"Connected\" /* ConnectionState.Connected */) {\n                // stop() was called and transitioned the client into the Disconnecting state.\n                const message = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Error, message);\n                return Promise.reject(new _Errors__WEBPACK_IMPORTED_MODULE_2__.AbortError(message));\n            }\n            this._connectionStarted = true;\n        });\n    }\n    send(data) {\n        if (this._connectionState !== \"Connected\" /* ConnectionState.Connected */) {\n            console.log(\"connectionState\", this._connectionState);\n            return Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\"));\n        }\n        if (!this._sendQueue) {\n            this._sendQueue = new TransportSendQueue(this.transport);\n        }\n        // Transport will not be null if state is connected\n        return this._sendQueue.send(data);\n    }\n    stop(error) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._connectionState === \"Disconnected\" /* ConnectionState.Disconnected */) {\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnected state.`);\n                return Promise.resolve();\n            }\n            if (this._connectionState === \"Disconnecting\" /* ConnectionState.Disconnecting */) {\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\n                return this._stopPromise;\n            }\n            this._connectionState = \"Disconnecting\" /* ConnectionState.Disconnecting */;\n            this._stopPromise = new Promise((resolve) => {\n                // Don't complete stop() until stopConnection() completes.\n                this._stopPromiseResolver = resolve;\n            });\n            // stopInternal should never throw so just observe it.\n            yield this._stopInternal(error);\n            yield this._stopPromise;\n        });\n    }\n    _stopInternal(error) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Set error as soon as possible otherwise there is a race between\n            // the transport closing and providing an error and the error from a close message\n            // We would prefer the close message error.\n            this._stopError = error;\n            try {\n                yield this._startInternalPromise;\n            }\n            catch (e) {\n                // This exception is returned to the user as a rejected Promise from the start method.\n            }\n            // The transport's onclose will trigger stopConnection which will run our onclose event.\n            // The transport should always be set if currently connected. If it wasn't set, it's likely because\n            // stop was called during start() and start() failed.\n            if (this.transport) {\n                try {\n                    yield this.transport.stop();\n                }\n                catch (e) {\n                    this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Error, `HttpConnection.transport.stop() threw error '${e}'.`);\n                    this._stopConnection();\n                }\n                this.transport = undefined;\n            }\n            else {\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\n            }\n        });\n    }\n    _startInternal(transferFormat) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Store the original base url and the access token factory since they may change\n            // as part of negotiating\n            let url = this.baseUrl;\n            this._accessTokenFactory = this._options.accessTokenFactory;\n            this._httpClient._accessTokenFactory = this._accessTokenFactory;\n            try {\n                if (this._options.skipNegotiation) {\n                    if (this._options.transport === _ITransport__WEBPACK_IMPORTED_MODULE_4__.HttpTransportType.SocketTasks) {\n                        // No need to add a connection ID in this case\n                        this.transport = this._constructTransport(_ITransport__WEBPACK_IMPORTED_MODULE_4__.HttpTransportType.SocketTasks);\n                        // We should just call connect directly in this case.\n                        // No fallback or negotiate in this case.\n                        yield this._startTransport(url, transferFormat);\n                    }\n                    else {\n                        throw new Error(\"Negotiation can only be skipped when using the SocketTask transport directly.\");\n                    }\n                }\n                else {\n                    let negotiateResponse = null;\n                    let redirects = 0;\n                    do {\n                        negotiateResponse = yield this._getNegotiationResponse(url);\n                        // the user tries to stop the connection when it is being started\n                        if (this._connectionState === \"Disconnecting\" /* ConnectionState.Disconnecting */ || this._connectionState === \"Disconnected\" /* ConnectionState.Disconnected */) {\n                            throw new _Errors__WEBPACK_IMPORTED_MODULE_2__.AbortError(\"The connection was stopped during negotiation.\");\n                        }\n                        if (negotiateResponse.error) {\n                            throw new Error(negotiateResponse.error);\n                        }\n                        if (negotiateResponse.ProtocolVersion) {\n                            throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\n                        }\n                        if (negotiateResponse.url) {\n                            url = negotiateResponse.url;\n                        }\n                        if (negotiateResponse.accessToken) {\n                            // Replace the current access token factory with one that uses\n                            // the returned access token\n                            const accessToken = negotiateResponse.accessToken;\n                            this._accessTokenFactory = () => accessToken;\n                            // set the factory to undefined so the AccessTokenHttpClient won't retry with the same token, since we know it won't change until a connection restart\n                            this._httpClient._accessToken = accessToken;\n                            this._httpClient._accessTokenFactory = undefined;\n                        }\n                        redirects++;\n                    } while (negotiateResponse.url && redirects < MAX_REDIRECTS);\n                    if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\n                        throw new Error(\"Negotiate redirection limit exceeded.\");\n                    }\n                    yield this._createTransport(url, this._options.transport, negotiateResponse, transferFormat);\n                }\n                if (this.transport instanceof _LongPollingTransport__WEBPACK_IMPORTED_MODULE_5__.LongPollingTransport) {\n                    this.features.inherentKeepAlive = true;\n                }\n                console.log(\"current this._connectionState\", this._connectionState);\n                if (this._connectionState === \"Connecting\" /* ConnectionState.Connecting */) {\n                    // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.\n                    // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.\n                    this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, \"The HttpConnection connected successfully.\");\n                    this._connectionState = \"Connected\" /* ConnectionState.Connected */;\n                }\n                // stop() is waiting on us via this.startInternalPromise so keep this.transport around so it can clean up.\n                // This is the only case startInternal can exit in neither the connected nor disconnected state because stopConnection()\n                // will transition to the disconnected state. start() will wait for the transition using the stopPromise.\n            }\n            catch (e) {\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Error, \"Failed to start the connection: \" + e);\n                this._connectionState = \"Disconnected\" /* ConnectionState.Disconnected */;\n                this.transport = undefined;\n                // if start fails, any active calls to stop assume that start will complete the stop promise\n                this._stopPromiseResolver();\n                return Promise.reject(e);\n            }\n        });\n    }\n    _getNegotiationResponse(url) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const headers = {};\n            const [name, value] = (0,_Utils__WEBPACK_IMPORTED_MODULE_7__.getUserAgentHeader)();\n            headers[name] = value;\n            const negotiateUrl = this._resolveNegotiateUrl(url);\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, `Sending negotiation request: ${negotiateUrl}.`);\n            try {\n                const response = yield this._httpClient.post(negotiateUrl, {\n                    content: \"\",\n                    headers: Object.assign(Object.assign({}, headers), this._options.headers),\n                    timeout: this._options.timeout,\n                    //withCredentials: this._options.withCredentials,\n                });\n                if (response.statusCode !== 200) {\n                    return Promise.reject(new Error(`Unexpected status code returned from negotiate '${response.statusCode}'`));\n                }\n                const negotiateResponse = JSON.parse(response.content);\n                if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {\n                    // Negotiate version 0 doesn't use connectionToken\n                    // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version\n                    negotiateResponse.connectionToken = negotiateResponse.connectionId;\n                }\n                return negotiateResponse;\n            }\n            catch (e) {\n                let errorMessage = \"Failed to complete negotiation with the server: \" + e;\n                if (e instanceof _Errors__WEBPACK_IMPORTED_MODULE_2__.HttpError) {\n                    if (e.statusCode === 404) {\n                        errorMessage = errorMessage + \" Either this is not a SignalR endpoint or there is a proxy blocking the connection.\";\n                    }\n                }\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Error, errorMessage);\n                return Promise.reject(new _Errors__WEBPACK_IMPORTED_MODULE_2__.FailedToNegotiateWithServerError(errorMessage));\n            }\n        });\n    }\n    _createConnectUrl(url, connectionToken) {\n        if (!connectionToken) {\n            return url;\n        }\n        return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + `id=${connectionToken}`;\n    }\n    _createTransport(url, requestedTransport, negotiateResponse, requestedTransferFormat) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let connectUrl = this._createConnectUrl(url, negotiateResponse.connectionToken);\n            if (this._isITransport(requestedTransport)) {\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\n                this.transport = requestedTransport;\n                yield this._startTransport(connectUrl, requestedTransferFormat);\n                this.connectionId = negotiateResponse.connectionId;\n                return;\n            }\n            const transportExceptions = [];\n            const transports = negotiateResponse.availableTransports || [];\n            let negotiate = negotiateResponse;\n            for (const endpoint of transports) {\n                const transportOrError = this._resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat);\n                if (transportOrError instanceof Error) {\n                    // Store the error and continue, we don't want to cause a re-negotiate in these cases\n                    transportExceptions.push(`${endpoint.transport} failed:`);\n                    transportExceptions.push(transportOrError);\n                }\n                else if (this._isITransport(transportOrError)) {\n                    this.transport = transportOrError;\n                    if (!negotiate) {\n                        try {\n                            negotiate = yield this._getNegotiationResponse(url);\n                        }\n                        catch (ex) {\n                            return Promise.reject(ex);\n                        }\n                        connectUrl = this._createConnectUrl(url, negotiate.connectionToken);\n                    }\n                    try {\n                        yield this._startTransport(connectUrl, requestedTransferFormat);\n                        this.connectionId = negotiate.connectionId;\n                        return;\n                    }\n                    catch (ex) {\n                        this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Error, `Failed to start the transport '${endpoint.transport}': ${ex}`);\n                        negotiate = undefined;\n                        transportExceptions.push(new _Errors__WEBPACK_IMPORTED_MODULE_2__.FailedToStartTransportError(`${endpoint.transport} failed: ${ex}`, _ITransport__WEBPACK_IMPORTED_MODULE_4__.HttpTransportType[endpoint.transport]));\n                        if (this._connectionState !== \"Connecting\" /* ConnectionState.Connecting */) {\n                            const message = \"Failed to select transport before stop() was called.\";\n                            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, message);\n                            return Promise.reject(new _Errors__WEBPACK_IMPORTED_MODULE_2__.AbortError(message));\n                        }\n                    }\n                }\n            }\n            if (transportExceptions.length > 0) {\n                return Promise.reject(new _Errors__WEBPACK_IMPORTED_MODULE_2__.AggregateErrors(`Unable to connect to the server with any of the available transports. ${transportExceptions.join(\" \")}`, transportExceptions));\n            }\n            return Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"));\n        });\n    }\n    _constructTransport(transport) {\n        switch (transport) {\n            case _ITransport__WEBPACK_IMPORTED_MODULE_4__.HttpTransportType.SocketTasks:\n                if (!this._options.SocketTask) {\n                    throw new Error(\"'SocketTask' is not supported in your environment.\");\n                }\n                return new _WebSocketTransport__WEBPACK_IMPORTED_MODULE_8__.SocketTaskTransport(this._httpClient, this._accessTokenFactory, this._logger, this._options.logMessageContent, this._options.SocketTask, this._options.headers || {});\n            case _ITransport__WEBPACK_IMPORTED_MODULE_4__.HttpTransportType.ServerSentEvents:\n                if (!this._options.EventSource) {\n                    throw new Error(\"'EventSource' is not supported in your environment.\");\n                }\n                return new _ServerSentEventsTransport__WEBPACK_IMPORTED_MODULE_6__.ServerSentEventsTransport(this._httpClient, this._httpClient._accessToken, this._logger, this._options);\n            case _ITransport__WEBPACK_IMPORTED_MODULE_4__.HttpTransportType.LongPolling:\n                return new _LongPollingTransport__WEBPACK_IMPORTED_MODULE_5__.LongPollingTransport(this._httpClient, this._logger, this._options);\n            default:\n                throw new Error(`Unknown transport: ${transport}.`);\n        }\n    }\n    _startTransport(url, transferFormat) {\n        this.transport.onreceive = this.onreceive;\n        this.transport.onclose = (e) => this._stopConnection(e);\n        return this.transport.connect(url, transferFormat);\n    }\n    _resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat) {\n        const transport = _ITransport__WEBPACK_IMPORTED_MODULE_4__.HttpTransportType[endpoint.transport];\n        if (transport === null || transport === undefined) {\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, `Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\n            return new Error(`Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\n        }\n        else {\n            if (transportMatches(requestedTransport, transport)) {\n                const transferFormats = endpoint.transferFormats.map((s) => _ITransport__WEBPACK_IMPORTED_MODULE_4__.TransferFormat[s]);\n                if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\n                    if ((transport === _ITransport__WEBPACK_IMPORTED_MODULE_4__.HttpTransportType.SocketTasks && !this._options.SocketTask) ||\n                        (transport === _ITransport__WEBPACK_IMPORTED_MODULE_4__.HttpTransportType.ServerSentEvents && !this._options.EventSource)) {\n                        this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, `Skipping transport '${_ITransport__WEBPACK_IMPORTED_MODULE_4__.HttpTransportType[transport]}' because it is not supported in your environment.'`);\n                        return new _Errors__WEBPACK_IMPORTED_MODULE_2__.UnsupportedTransportError(`'${_ITransport__WEBPACK_IMPORTED_MODULE_4__.HttpTransportType[transport]}' is not supported in your environment.`, transport);\n                    }\n                    else {\n                        this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, `Selecting transport '${_ITransport__WEBPACK_IMPORTED_MODULE_4__.HttpTransportType[transport]}'.`);\n                        try {\n                            return this._constructTransport(transport);\n                        }\n                        catch (ex) {\n                            //return ex;\n                            return new Error(ex.toString());\n                        }\n                    }\n                }\n                else {\n                    this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, `Skipping transport '${_ITransport__WEBPACK_IMPORTED_MODULE_4__.HttpTransportType[transport]}' because it does not support the requested transfer format '${_ITransport__WEBPACK_IMPORTED_MODULE_4__.TransferFormat[requestedTransferFormat]}'.`);\n                    return new Error(`'${_ITransport__WEBPACK_IMPORTED_MODULE_4__.HttpTransportType[transport]}' does not support ${_ITransport__WEBPACK_IMPORTED_MODULE_4__.TransferFormat[requestedTransferFormat]}.`);\n                }\n            }\n            else {\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, `Skipping transport '${_ITransport__WEBPACK_IMPORTED_MODULE_4__.HttpTransportType[transport]}' because it was disabled by the client.`);\n                return new _Errors__WEBPACK_IMPORTED_MODULE_2__.DisabledTransportError(`'${_ITransport__WEBPACK_IMPORTED_MODULE_4__.HttpTransportType[transport]}' is disabled by the client.`, transport);\n            }\n        }\n    }\n    _isITransport(transport) {\n        return transport && typeof (transport) === \"object\" && \"connect\" in transport;\n    }\n    _stopConnection(error) {\n        this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, `HttpConnection.stopConnection(${error}) called while in state ${this._connectionState}.`);\n        this.transport = undefined;\n        // If we have a stopError, it takes precedence over the error from the transport\n        error = this._stopError || error;\n        this._stopError = undefined;\n        if (this._connectionState === \"Disconnected\" /* ConnectionState.Disconnected */) {\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is already in the disconnected state.`);\n            return;\n        }\n        if (this._connectionState === \"Connecting\" /* ConnectionState.Connecting */) {\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Warning, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is still in the connecting state.`);\n            throw new Error(`HttpConnection.stopConnection(${error}) was called while the connection is still in the connecting state.`);\n        }\n        if (this._connectionState === \"Disconnecting\" /* ConnectionState.Disconnecting */) {\n            // A call to stop() induced this call to stopConnection and needs to be completed.\n            // Any stop() awaiters will be scheduled to continue after the onclose callback fires.\n            this._stopPromiseResolver();\n        }\n        if (error) {\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Error, `Connection disconnected with error '${error}'.`);\n        }\n        else {\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Information, \"Connection disconnected.\");\n        }\n        if (this._sendQueue) {\n            this._sendQueue.stop().catch((e) => {\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Error, `TransportSendQueue.stop() threw error '${e}'.`);\n            });\n            this._sendQueue = undefined;\n        }\n        this.connectionId = undefined;\n        this._connectionState = \"Disconnected\" /* ConnectionState.Disconnected */;\n        if (this._connectionStarted) {\n            this._connectionStarted = false;\n            try {\n                if (this.onclose) {\n                    this.onclose(error);\n                }\n            }\n            catch (e) {\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Error, `HttpConnection.onclose(${error}) threw error '${e}'.`);\n            }\n        }\n    }\n    _resolveUrl(url) {\n        // startsWith is not supported in IE\n        if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\n            return url;\n        }\n        if (!_Utils__WEBPACK_IMPORTED_MODULE_7__.Platform.isBrowser) {\n            throw new Error(`Cannot resolve '${url}'.`);\n        }\n        // Setting the url to the href propery of an anchor tag handles normalization\n        // for us. There are 3 main cases.\n        // 1. Relative path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\n        // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\n        // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\n        const aTag = window.document.createElement(\"a\");\n        aTag.href = url;\n        this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Information, `Normalizing '${url}' to '${aTag.href}'.`);\n        return aTag.href;\n    }\n    _resolveNegotiateUrl(url) {\n        const index = url.indexOf(\"?\");\n        let negotiateUrl = url.substring(0, index === -1 ? url.length : index);\n        if (negotiateUrl[negotiateUrl.length - 1] !== \"/\") {\n            negotiateUrl += \"/\";\n        }\n        negotiateUrl += \"negotiate\";\n        negotiateUrl += index === -1 ? \"\" : url.substring(index);\n        if (negotiateUrl.indexOf(\"negotiateVersion\") === -1) {\n            negotiateUrl += index === -1 ? \"?\" : \"&\";\n            negotiateUrl += \"negotiateVersion=\" + this._negotiateVersion;\n        }\n        return negotiateUrl;\n    }\n}\nfunction transportMatches(requestedTransport, actualTransport) {\n    return !requestedTransport || ((actualTransport & requestedTransport) !== 0);\n}\n/** @private */\nclass TransportSendQueue {\n    constructor(_transport) {\n        this._transport = _transport;\n        this._buffer = [];\n        this._executing = true;\n        this._sendBufferedData = new PromiseSource();\n        this._transportResult = new PromiseSource();\n        this._sendLoopPromise = this._sendLoop();\n    }\n    send(data) {\n        this._bufferData(data);\n        if (!this._transportResult) {\n            this._transportResult = new PromiseSource();\n        }\n        return this._transportResult.promise;\n    }\n    stop() {\n        this._executing = false;\n        this._sendBufferedData.resolve();\n        return this._sendLoopPromise;\n    }\n    _bufferData(data) {\n        if (this._buffer.length && typeof (this._buffer[0]) !== typeof (data)) {\n            throw new Error(`Expected data to be of type ${typeof (this._buffer)} but was of type ${typeof (data)}`);\n        }\n        this._buffer.push(data);\n        this._sendBufferedData.resolve();\n    }\n    _sendLoop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            while (true) {\n                yield this._sendBufferedData.promise;\n                if (!this._executing) {\n                    if (this._transportResult) {\n                        this._transportResult.reject(\"Connection stopped.\");\n                    }\n                    break;\n                }\n                this._sendBufferedData = new PromiseSource();\n                const transportResult = this._transportResult;\n                this._transportResult = undefined;\n                const data = typeof (this._buffer[0]) === \"string\" ?\n                    this._buffer.join(\"\") :\n                    TransportSendQueue._concatBuffers(this._buffer);\n                this._buffer.length = 0;\n                try {\n                    yield this._transport.send(data);\n                    transportResult.resolve();\n                }\n                catch (error) {\n                    transportResult.reject(error);\n                }\n            }\n        });\n    }\n    static _concatBuffers(arrayBuffers) {\n        const totalLength = arrayBuffers.map((b) => b.byteLength).reduce((a, b) => a + b);\n        const result = new Uint8Array(totalLength);\n        let offset = 0;\n        for (const item of arrayBuffers) {\n            result.set(new Uint8Array(item), offset);\n            offset += item.byteLength;\n        }\n        return result.buffer;\n    }\n}\nclass PromiseSource {\n    constructor() {\n        this.promise = new Promise((resolve, reject) => [this._resolver, this._rejecter] = [resolve, reject]);\n    }\n    resolve() {\n        this._resolver();\n    }\n    reject(reason) {\n        this._rejecter(reason);\n    }\n}\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/HttpConnection.ts?");

/***/ }),

/***/ "./src/HubConnection.ts":
/*!******************************!*\
  !*** ./src/HubConnection.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HubConnection: () => (/* binding */ HubConnection),\n/* harmony export */   HubConnectionState: () => (/* binding */ HubConnectionState)\n/* harmony export */ });\n/* harmony import */ var _HandshakeProtocol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HandshakeProtocol */ \"./src/HandshakeProtocol.ts\");\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Errors */ \"./src/Errors.ts\");\n/* harmony import */ var _IHubProtocol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IHubProtocol */ \"./src/IHubProtocol.ts\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ILogger */ \"./src/ILogger.ts\");\n/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Subject */ \"./src/Subject.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Utils */ \"./src/Utils.ts\");\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\nconst DEFAULT_TIMEOUT_IN_MS = 30 * 1000;\nconst DEFAULT_PING_INTERVAL_IN_MS = 15 * 1000;\n/** Describes the current state of the {@link HubConnection} to the server. */\nvar HubConnectionState;\n(function (HubConnectionState) {\n    /** The hub connection is disconnected. */\n    HubConnectionState[\"Disconnected\"] = \"Disconnected\";\n    /** The hub connection is connecting. */\n    HubConnectionState[\"Connecting\"] = \"Connecting\";\n    /** The hub connection is connected. */\n    HubConnectionState[\"Connected\"] = \"Connected\";\n    /** The hub connection is disconnecting. */\n    HubConnectionState[\"Disconnecting\"] = \"Disconnecting\";\n    /** The hub connection is reconnecting. */\n    HubConnectionState[\"Reconnecting\"] = \"Reconnecting\";\n})(HubConnectionState || (HubConnectionState = {}));\n/** Represents a connection to a SignalR Hub. */\nclass HubConnection {\n    /** @internal */\n    // Using a public static factory method means we can have a private constructor and an _internal_\n    // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\n    // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\n    // public parameter-less constructor.\n    static create(connection, logger, protocol, reconnectPolicy) {\n        return new HubConnection(connection, logger, protocol, reconnectPolicy);\n    }\n    constructor(connection, logger, protocol, reconnectPolicy) {\n        this._nextKeepAlive = 0;\n        this._freezeEventListener = () => {\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Warning, \"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://docs.microsoft.com/aspnet/core/signalr/javascript-client#bsleep\");\n        };\n        _Utils__WEBPACK_IMPORTED_MODULE_5__.Arg.isRequired(connection, \"connection\");\n        _Utils__WEBPACK_IMPORTED_MODULE_5__.Arg.isRequired(logger, \"logger\");\n        _Utils__WEBPACK_IMPORTED_MODULE_5__.Arg.isRequired(protocol, \"protocol\");\n        this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\n        this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;\n        this._logger = logger;\n        this._protocol = protocol;\n        this.connection = connection;\n        this._reconnectPolicy = reconnectPolicy;\n        this._handshakeProtocol = new _HandshakeProtocol__WEBPACK_IMPORTED_MODULE_0__.HandshakeProtocol();\n        this.connection.onreceive = (data) => this._processIncomingData(data);\n        this.connection.onclose = (error) => this._connectionClosed(error);\n        this._callbacks = {};\n        this._methods = {};\n        this._closedCallbacks = [];\n        this._reconnectingCallbacks = [];\n        this._reconnectedCallbacks = [];\n        this._invocationId = 0;\n        this._receivedHandshakeResponse = false;\n        this._connectionState = HubConnectionState.Disconnected;\n        this._connectionStarted = false;\n        this._cachedPingMessage = this._protocol.writeMessage({ type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_2__.MessageType.Ping });\n    }\n    /** Indicates the state of the {@link HubConnection} to the server. */\n    get state() {\n        return this._connectionState;\n    }\n    /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\n     *  in the disconnected state or if the negotiation step was skipped.\n     */\n    get connectionId() {\n        return this.connection ? (this.connection.connectionId || null) : null;\n    }\n    /** Indicates the url of the {@link HubConnection} to the server. */\n    get baseUrl() {\n        return this.connection.baseUrl || \"\";\n    }\n    /**\n     * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\n     * Reconnecting states.\n     * @param {string} url The url to connect to.\n     */\n    set baseUrl(url) {\n        if (this._connectionState !== HubConnectionState.Disconnected && this._connectionState !== HubConnectionState.Reconnecting) {\n            throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\n        }\n        if (!url) {\n            throw new Error(\"The HubConnection url must be a valid url.\");\n        }\n        this.connection.baseUrl = url;\n    }\n    /** Starts the connection.\n     *\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\n     */\n    start() {\n        this._startPromise = this._startWithStateTransitions();\n        return this._startPromise;\n    }\n    _startWithStateTransitions() {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log(\"this._connectionState\", this._connectionState);\n            if (this._connectionState !== HubConnectionState.Disconnected) {\n                return Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\"));\n            }\n            //this._connectionState = HubConnectionState.Connecting;\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, \"Starting HubConnection.\");\n            try {\n                yield this._startInternal();\n                if (_Utils__WEBPACK_IMPORTED_MODULE_5__.Platform.isBrowser) {\n                    // Log when the browser freezes the tab so users know why their connection unexpectedly stopped working\n                    window.document.addEventListener(\"freeze\", this._freezeEventListener);\n                }\n                this._connectionState = HubConnectionState.Connected;\n                this._connectionStarted = true;\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, \"HubConnection connected successfully.\");\n            }\n            catch (e) {\n                this._connectionState = HubConnectionState.Disconnected;\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, `HubConnection failed to start successfully because of error '${e}'.`);\n                return Promise.reject(e);\n            }\n        });\n    }\n    _startInternal() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._stopDuringStartError = undefined;\n            this._receivedHandshakeResponse = false;\n            // Set up the promise before any connection is (re)started otherwise it could race with received messages\n            const handshakePromise = new Promise((resolve, reject) => {\n                this._handshakeResolver = resolve;\n                this._handshakeRejecter = reject;\n            });\n            yield this.connection.start(this._protocol.transferFormat);\n            try {\n                const handshakeRequest = {\n                    protocol: this._protocol.name,\n                    version: this._protocol.version,\n                };\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, \"Sending handshake request.\");\n                yield this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(handshakeRequest));\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Information, `Using HubProtocol '${this._protocol.name}'.`);\n                // defensively cleanup timeout in case we receive a message from the server before we finish start\n                this._cleanupTimeout();\n                this._resetTimeoutPeriod();\n                this._resetKeepAliveInterval();\n                yield handshakePromise;\n                // It's important to check the stopDuringStartError instead of just relying on the handshakePromise\n                // being rejected on close, because this continuation can run after both the handshake completed successfully\n                // and the connection was closed.\n                if (this._stopDuringStartError) {\n                    // It's important to throw instead of returning a rejected promise, because we don't want to allow any state\n                    // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise\n                    // will cause the calling continuation to get scheduled to run later.\n                    // eslint-disable-next-line @typescript-eslint/no-throw-literal\n                    throw this._stopDuringStartError;\n                }\n                if (!this.connection.features.inherentKeepAlive) {\n                    yield this._sendMessage(this._cachedPingMessage);\n                }\n            }\n            catch (e) {\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, `Hub handshake failed with error '${e}' during start(). Stopping HubConnection.`);\n                this._cleanupTimeout();\n                this._cleanupPingTimer();\n                // HttpConnection.stop() should not complete until after the onclose callback is invoked.\n                // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\n                yield this.connection.stop(e);\n                throw e;\n            }\n        });\n    }\n    /** Stops the connection.\n     *\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\n     */\n    stop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Capture the start promise before the connection might be restarted in an onclose callback.\n            const startPromise = this._startPromise;\n            this._stopPromise = this._stopInternal();\n            yield this._stopPromise;\n            try {\n                // Awaiting undefined continues immediately\n                yield startPromise;\n            }\n            catch (e) {\n                // This exception is returned to the user as a rejected Promise from the start method.\n            }\n        });\n    }\n    _stopInternal(error) {\n        if (this._connectionState === HubConnectionState.Disconnected) {\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, `Call to HubConnection.stop(${error}) ignored because it is already in the disconnected state.`);\n            return Promise.resolve();\n        }\n        if (this._connectionState === HubConnectionState.Disconnecting) {\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\n            return this._stopPromise;\n        }\n        this._connectionState = HubConnectionState.Disconnecting;\n        this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, \"Stopping HubConnection.\");\n        if (this._reconnectDelayHandle) {\n            // We're in a reconnect delay which means the underlying connection is currently already stopped.\n            // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and\n            // fire the onclose callbacks.\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\");\n            clearTimeout(this._reconnectDelayHandle);\n            this._reconnectDelayHandle = undefined;\n            this._completeClose();\n            return Promise.resolve();\n        }\n        this._cleanupTimeout();\n        this._cleanupPingTimer();\n        this._stopDuringStartError = error || new _Errors__WEBPACK_IMPORTED_MODULE_1__.AbortError(\"The connection was stopped before the hub handshake could complete.\");\n        // HttpConnection.stop() should not complete until after either HttpConnection.start() fails\n        // or the onclose callback is invoked. The onclose callback will transition the HubConnection\n        // to the disconnected state if need be before HttpConnection.stop() completes.\n        return this.connection.stop(error);\n    }\n    /** Invokes a streaming hub method on the server using the specified name and arguments.\n     *\n     * @typeparam T The type of the items returned by the server.\n     * @param {string} methodName The name of the server method to invoke.\n     * @param {any[]} args The arguments used to invoke the server method.\n     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\n     */\n    stream(methodName, ...args) {\n        const [streams, streamIds] = this._replaceStreamingParams(args);\n        const invocationDescriptor = this._createStreamInvocation(methodName, args, streamIds);\n        // eslint-disable-next-line prefer-const\n        let promiseQueue;\n        const subject = new _Subject__WEBPACK_IMPORTED_MODULE_4__.Subject();\n        subject.cancelCallback = () => {\n            const cancelInvocation = this._createCancelInvocation(invocationDescriptor.invocationId);\n            delete this._callbacks[invocationDescriptor.invocationId];\n            return promiseQueue.then(() => {\n                return this._sendWithProtocol(cancelInvocation);\n            });\n        };\n        this._callbacks[invocationDescriptor.invocationId] = (invocationEvent, error) => {\n            if (error) {\n                subject.error(error);\n                return;\n            }\n            else if (invocationEvent) {\n                // invocationEvent will not be null when an error is not passed to the callback\n                if (invocationEvent.type === _IHubProtocol__WEBPACK_IMPORTED_MODULE_2__.MessageType.Completion) {\n                    if (invocationEvent.error) {\n                        subject.error(new Error(invocationEvent.error));\n                    }\n                    else {\n                        subject.complete();\n                    }\n                }\n                else {\n                    subject.next((invocationEvent.item));\n                }\n            }\n        };\n        promiseQueue = this._sendWithProtocol(invocationDescriptor)\n            .catch((e) => {\n            subject.error(e);\n            delete this._callbacks[invocationDescriptor.invocationId];\n        });\n        this._launchStreams(streams, promiseQueue);\n        return subject;\n    }\n    _sendMessage(message) {\n        this._resetKeepAliveInterval();\n        return this.connection.send(message);\n    }\n    /**\n     * Sends a js object to the server.\n     * @param message The js object to serialize and send.\n     */\n    _sendWithProtocol(message) {\n        return this._sendMessage(this._protocol.writeMessage(message));\n    }\n    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\n     *\n     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\n     * be processing the invocation.\n     *\n     * @param {string} methodName The name of the server method to invoke.\n     * @param {any[]} args The arguments used to invoke the server method.\n     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\n     */\n    send(methodName, ...args) {\n        const [streams, streamIds] = this._replaceStreamingParams(args);\n        const sendPromise = this._sendWithProtocol(this._createInvocation(methodName, args, true, streamIds));\n        this._launchStreams(streams, sendPromise);\n        return sendPromise;\n    }\n    /** Invokes a hub method on the server using the specified name and arguments.\n     *\n     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\n     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\n     * resolving the Promise.\n     *\n     * @typeparam T The expected return type.\n     * @param {string} methodName The name of the server method to invoke.\n     * @param {any[]} args The arguments used to invoke the server method.\n     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\n     */\n    invoke(methodName, ...args) {\n        const [streams, streamIds] = this._replaceStreamingParams(args);\n        const invocationDescriptor = this._createInvocation(methodName, args, false, streamIds);\n        const p = new Promise((resolve, reject) => {\n            // invocationId will always have a value for a non-blocking invocation\n            this._callbacks[invocationDescriptor.invocationId] = (invocationEvent, error) => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                else if (invocationEvent) {\n                    // invocationEvent will not be null when an error is not passed to the callback\n                    if (invocationEvent.type === _IHubProtocol__WEBPACK_IMPORTED_MODULE_2__.MessageType.Completion) {\n                        if (invocationEvent.error) {\n                            reject(new Error(invocationEvent.error));\n                        }\n                        else {\n                            resolve(invocationEvent.result);\n                        }\n                    }\n                    else {\n                        reject(new Error(`Unexpected message type: ${invocationEvent.type}`));\n                    }\n                }\n            };\n            const promiseQueue = this._sendWithProtocol(invocationDescriptor)\n                .catch((e) => {\n                reject(e);\n                // invocationId will always have a value for a non-blocking invocation\n                delete this._callbacks[invocationDescriptor.invocationId];\n            });\n            this._launchStreams(streams, promiseQueue);\n        });\n        return p;\n    }\n    on(methodName, newMethod) {\n        if (!methodName || !newMethod) {\n            return;\n        }\n        methodName = methodName.toLowerCase();\n        if (!this._methods[methodName]) {\n            this._methods[methodName] = [];\n        }\n        // Preventing adding the same handler multiple times.\n        if (this._methods[methodName].indexOf(newMethod) !== -1) {\n            return;\n        }\n        this._methods[methodName].push(newMethod);\n    }\n    off(methodName, method) {\n        if (!methodName) {\n            return;\n        }\n        methodName = methodName.toLowerCase();\n        const handlers = this._methods[methodName];\n        if (!handlers) {\n            return;\n        }\n        if (method) {\n            const removeIdx = handlers.indexOf(method);\n            if (removeIdx !== -1) {\n                handlers.splice(removeIdx, 1);\n                if (handlers.length === 0) {\n                    delete this._methods[methodName];\n                }\n            }\n        }\n        else {\n            delete this._methods[methodName];\n        }\n    }\n    /** Registers a handler that will be invoked when the connection is closed.\n     *\n     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\n     */\n    onclose(callback) {\n        if (callback) {\n            this._closedCallbacks.push(callback);\n        }\n    }\n    /** Registers a handler that will be invoked when the connection starts reconnecting.\n     *\n     * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\n     */\n    onreconnecting(callback) {\n        if (callback) {\n            this._reconnectingCallbacks.push(callback);\n        }\n    }\n    /** Registers a handler that will be invoked when the connection successfully reconnects.\n     *\n     * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\n     */\n    onreconnected(callback) {\n        if (callback) {\n            this._reconnectedCallbacks.push(callback);\n        }\n    }\n    _processIncomingData(data) {\n        this._cleanupTimeout();\n        if (!this._receivedHandshakeResponse) {\n            data = this._processHandshakeResponse(data);\n            this._receivedHandshakeResponse = true;\n        }\n        // Data may have all been read when processing handshake response\n        if (data) {\n            // Parse the messages\n            const messages = this._protocol.parseMessages(data, this._logger);\n            for (const message of messages) {\n                switch (message.type) {\n                    case _IHubProtocol__WEBPACK_IMPORTED_MODULE_2__.MessageType.Invocation:\n                        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                        this._invokeClientMethod(message);\n                        break;\n                    case _IHubProtocol__WEBPACK_IMPORTED_MODULE_2__.MessageType.StreamItem:\n                    case _IHubProtocol__WEBPACK_IMPORTED_MODULE_2__.MessageType.Completion: {\n                        const callback = this._callbacks[message.invocationId];\n                        if (callback) {\n                            if (message.type === _IHubProtocol__WEBPACK_IMPORTED_MODULE_2__.MessageType.Completion) {\n                                delete this._callbacks[message.invocationId];\n                            }\n                            try {\n                                callback(message);\n                            }\n                            catch (e) {\n                                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Error, `Stream callback threw error: ${(0,_Utils__WEBPACK_IMPORTED_MODULE_5__.getErrorString)(e)}`);\n                            }\n                        }\n                        break;\n                    }\n                    case _IHubProtocol__WEBPACK_IMPORTED_MODULE_2__.MessageType.Ping:\n                        // Don't care about pings\n                        break;\n                    case _IHubProtocol__WEBPACK_IMPORTED_MODULE_2__.MessageType.Close: {\n                        this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Information, \"Close message received from server.\");\n                        const error = message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined;\n                        if (message.allowReconnect === true) {\n                            // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,\n                            // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.\n                            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                            this.connection.stop(error);\n                        }\n                        else {\n                            // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.\n                            this._stopPromise = this._stopInternal(error);\n                        }\n                        break;\n                    }\n                    default:\n                        this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Warning, `Invalid message type: ${message.type}.`);\n                        break;\n                }\n            }\n        }\n        this._resetTimeoutPeriod();\n    }\n    _processHandshakeResponse(data) {\n        let responseMessage;\n        let remainingData;\n        try {\n            [remainingData, responseMessage] = this._handshakeProtocol.parseHandshakeResponse(data);\n        }\n        catch (e) {\n            const message = \"Error parsing handshake response: \" + e;\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Error, message);\n            const error = new Error(message);\n            this._handshakeRejecter(error);\n            throw error;\n        }\n        if (responseMessage.error) {\n            const message = \"Server returned handshake error: \" + responseMessage.error;\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Error, message);\n            const error = new Error(message);\n            this._handshakeRejecter(error);\n            throw error;\n        }\n        else {\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, \"Server handshake complete.\");\n        }\n        this._handshakeResolver();\n        return remainingData;\n    }\n    _resetKeepAliveInterval() {\n        if (this.connection.features.inherentKeepAlive) {\n            return;\n        }\n        // Set the time we want the next keep alive to be sent\n        // Timer will be setup on next message receive\n        this._nextKeepAlive = new Date().getTime() + this.keepAliveIntervalInMilliseconds;\n        this._cleanupPingTimer();\n    }\n    _resetTimeoutPeriod() {\n        if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\n            // Set the timeout timer\n            this._timeoutHandle = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds);\n            // Set keepAlive timer if there isn't one\n            if (this._pingServerHandle === undefined) {\n                let nextPing = this._nextKeepAlive - new Date().getTime();\n                if (nextPing < 0) {\n                    nextPing = 0;\n                }\n                // The timer needs to be set from a networking callback to avoid Chrome timer throttling from causing timers to run once a minute\n                this._pingServerHandle = setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                    if (this._connectionState === HubConnectionState.Connected) {\n                        try {\n                            yield this._sendMessage(this._cachedPingMessage);\n                        }\n                        catch (_a) {\n                            // We don't care about the error. It should be seen elsewhere in the client.\n                            // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\n                            this._cleanupPingTimer();\n                        }\n                    }\n                }), nextPing);\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    serverTimeout() {\n        // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\n        // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\n    }\n    _invokeClientMethod(invocationMessage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const methodName = invocationMessage.target.toLowerCase();\n            const methods = this._methods[methodName];\n            if (!methods) {\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Warning, `No client method with the name '${methodName}' found.`);\n                // No handlers provided by client but the server is expecting a response still, so we send an error\n                if (invocationMessage.invocationId) {\n                    this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Warning, `No result given for '${methodName}' method and invocation ID '${invocationMessage.invocationId}'.`);\n                    yield this._sendWithProtocol(this._createCompletionMessage(invocationMessage.invocationId, \"Client didn't provide a result.\", null));\n                }\n                return;\n            }\n            // Avoid issues with handlers removing themselves thus modifying the list while iterating through it\n            const methodsCopy = methods.slice();\n            // Server expects a response\n            const expectsResponse = invocationMessage.invocationId ? true : false;\n            // We preserve the last result or exception but still call all handlers\n            let res;\n            let exception;\n            let completionMessage;\n            for (const m of methodsCopy) {\n                try {\n                    const prevRes = res;\n                    res = yield m.apply(this, invocationMessage.arguments);\n                    if (expectsResponse && res && prevRes) {\n                        this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Error, `Multiple results provided for '${methodName}'. Sending error to server.`);\n                        completionMessage = this._createCompletionMessage(invocationMessage.invocationId, `Client provided multiple results.`, null);\n                    }\n                    // Ignore exception if we got a result after, the exception will be logged\n                    exception = undefined;\n                }\n                catch (e) {\n                    exception = e;\n                    this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Error, `A callback for the method '${methodName}' threw error '${e}'.`);\n                }\n            }\n            if (completionMessage) {\n                yield this._sendWithProtocol(completionMessage);\n            }\n            else if (expectsResponse) {\n                // If there is an exception that means either no result was given or a handler after a result threw\n                if (exception) {\n                    completionMessage = this._createCompletionMessage(invocationMessage.invocationId, `${exception}`, null);\n                }\n                else if (res !== undefined) {\n                    completionMessage = this._createCompletionMessage(invocationMessage.invocationId, null, res);\n                }\n                else {\n                    this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Warning, `No result given for '${methodName}' method and invocation ID '${invocationMessage.invocationId}'.`);\n                    // Client didn't provide a result or throw from a handler, server expects a response so we send an error\n                    completionMessage = this._createCompletionMessage(invocationMessage.invocationId, \"Client didn't provide a result.\", null);\n                }\n                yield this._sendWithProtocol(completionMessage);\n            }\n            else {\n                if (res) {\n                    this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Error, `Result given for '${methodName}' method but server is not expecting a result.`);\n                }\n            }\n        });\n    }\n    _connectionClosed(error) {\n        this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, `HubConnection.connectionClosed(${error}) called while in state ${this._connectionState}.`);\n        // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.\n        this._stopDuringStartError = this._stopDuringStartError || error || new _Errors__WEBPACK_IMPORTED_MODULE_1__.AbortError(\"The underlying connection was closed before the hub handshake could complete.\");\n        // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.\n        // If it has already completed, this should just noop.\n        if (this._handshakeResolver) {\n            this._handshakeResolver();\n        }\n        this._cancelCallbacksWithError(error || new Error(\"Invocation canceled due to the underlying connection being closed.\"));\n        this._cleanupTimeout();\n        this._cleanupPingTimer();\n        if (this._connectionState === HubConnectionState.Disconnecting) {\n            this._completeClose(error);\n        }\n        else if (this._connectionState === HubConnectionState.Connected && this._reconnectPolicy) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this._reconnect(error);\n        }\n        else if (this._connectionState === HubConnectionState.Connected) {\n            this._completeClose(error);\n        }\n        // If none of the above if conditions were true were called the HubConnection must be in either:\n        // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.\n        // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt\n        //    and potentially continue the reconnect() loop.\n        // 3. The Disconnected state in which case we're already done.\n    }\n    _completeClose(error) {\n        if (this._connectionStarted) {\n            this._connectionState = HubConnectionState.Disconnected;\n            this._connectionStarted = false;\n            if (_Utils__WEBPACK_IMPORTED_MODULE_5__.Platform.isBrowser) {\n                window.document.removeEventListener(\"freeze\", this._freezeEventListener);\n            }\n            try {\n                this._closedCallbacks.forEach((c) => c.apply(this, [error]));\n            }\n            catch (e) {\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Error, `An onclose callback called with error '${error}' threw error '${e}'.`);\n            }\n        }\n    }\n    _reconnect(error) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const reconnectStartTime = Date.now();\n            let previousReconnectAttempts = 0;\n            let retryError = error !== undefined ? error : new Error(\"Attempting to reconnect due to a unknown error.\");\n            let nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, 0, retryError);\n            if (nextRetryDelay === null) {\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\");\n                this._completeClose(error);\n                return;\n            }\n            this._connectionState = HubConnectionState.Reconnecting;\n            if (error) {\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Information, `Connection reconnecting because of error '${error}'.`);\n            }\n            else {\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Information, \"Connection reconnecting.\");\n            }\n            if (this._reconnectingCallbacks.length !== 0) {\n                try {\n                    this._reconnectingCallbacks.forEach((c) => c.apply(this, [error]));\n                }\n                catch (e) {\n                    this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Error, `An onreconnecting callback called with error '${error}' threw error '${e}'.`);\n                }\n                // Exit early if an onreconnecting callback called connection.stop().\n                if (this._connectionState !== HubConnectionState.Reconnecting) {\n                    this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\n                    return;\n                }\n            }\n            while (nextRetryDelay !== null) {\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Information, `Reconnect attempt number ${previousReconnectAttempts} will start in ${nextRetryDelay} ms.`);\n                yield new Promise((resolve) => {\n                    this._reconnectDelayHandle = setTimeout(resolve, nextRetryDelay);\n                });\n                this._reconnectDelayHandle = undefined;\n                if (this._connectionState !== HubConnectionState.Reconnecting) {\n                    this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\n                    return;\n                }\n                try {\n                    yield this._startInternal();\n                    this._connectionState = HubConnectionState.Connected;\n                    this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Information, \"HubConnection reconnected successfully.\");\n                    if (this._reconnectedCallbacks.length !== 0) {\n                        try {\n                            this._reconnectedCallbacks.forEach((c) => c.apply(this, [this.connection.connectionId]));\n                        }\n                        catch (e) {\n                            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${e}'.`);\n                        }\n                    }\n                    return;\n                }\n                catch (e) {\n                    this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Information, `Reconnect attempt failed because of error '${e}'.`);\n                    if (this._connectionState !== HubConnectionState.Reconnecting) {\n                        this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug, `Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`);\n                        // The TypeScript compiler thinks that connectionState must be Connected here. The TypeScript compiler is wrong.\n                        if (this._connectionState === HubConnectionState.Disconnecting) {\n                            this._completeClose();\n                        }\n                        return;\n                    }\n                    retryError = e instanceof Error ? e : new Error((_a = e === null || e === void 0 ? void 0 : e.toString()) !== null && _a !== void 0 ? _a : \"Unknown error occurred during retrying.\");\n                    nextRetryDelay = this._getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);\n                }\n            }\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Information, `Reconnect retries have been exhausted after ${Date.now() - reconnectStartTime} ms and ${previousReconnectAttempts} failed attempts. Connection disconnecting.`);\n            this._completeClose();\n        });\n    }\n    _getNextRetryDelay(previousRetryCount, elapsedMilliseconds, retryReason) {\n        try {\n            return this._reconnectPolicy.nextRetryDelayInMilliseconds({\n                elapsedMilliseconds,\n                previousRetryCount,\n                retryReason,\n            });\n        }\n        catch (e) {\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${previousRetryCount}, ${elapsedMilliseconds}) threw error '${e}'.`);\n            return null;\n        }\n    }\n    _cancelCallbacksWithError(error) {\n        const callbacks = this._callbacks;\n        this._callbacks = {};\n        Object.keys(callbacks)\n            .forEach((key) => {\n            const callback = callbacks[key];\n            try {\n                callback(null, error);\n            }\n            catch (e) {\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Error, `Stream 'error' callback called with '${error}' threw error: ${(0,_Utils__WEBPACK_IMPORTED_MODULE_5__.getErrorString)(e)}`);\n            }\n        });\n    }\n    _cleanupPingTimer() {\n        if (this._pingServerHandle) {\n            clearTimeout(this._pingServerHandle);\n            this._pingServerHandle = undefined;\n        }\n    }\n    _cleanupTimeout() {\n        if (this._timeoutHandle) {\n            clearTimeout(this._timeoutHandle);\n        }\n    }\n    _createInvocation(methodName, args, nonblocking, streamIds) {\n        if (nonblocking) {\n            if (streamIds.length !== 0) {\n                return {\n                    arguments: args,\n                    streamIds,\n                    target: methodName,\n                    type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_2__.MessageType.Invocation,\n                };\n            }\n            else {\n                return {\n                    arguments: args,\n                    target: methodName,\n                    type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_2__.MessageType.Invocation,\n                };\n            }\n        }\n        else {\n            const invocationId = this._invocationId;\n            this._invocationId++;\n            if (streamIds.length !== 0) {\n                return {\n                    arguments: args,\n                    invocationId: invocationId.toString(),\n                    streamIds,\n                    target: methodName,\n                    type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_2__.MessageType.Invocation,\n                };\n            }\n            else {\n                return {\n                    arguments: args,\n                    invocationId: invocationId.toString(),\n                    target: methodName,\n                    type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_2__.MessageType.Invocation,\n                };\n            }\n        }\n    }\n    _launchStreams(streams, promiseQueue) {\n        if (streams.length === 0) {\n            return;\n        }\n        // Synchronize stream data so they arrive in-order on the server\n        if (!promiseQueue) {\n            promiseQueue = Promise.resolve();\n        }\n        // We want to iterate over the keys, since the keys are the stream ids\n        // eslint-disable-next-line guard-for-in\n        for (const streamId in streams) {\n            streams[streamId].subscribe({\n                complete: () => {\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createCompletionMessage(streamId)));\n                },\n                error: (err) => {\n                    let message;\n                    if (err instanceof Error) {\n                        message = err.message;\n                    }\n                    else if (err && err.toString) {\n                        message = err.toString();\n                    }\n                    else {\n                        message = \"Unknown error\";\n                    }\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createCompletionMessage(streamId, message)));\n                },\n                next: (item) => {\n                    promiseQueue = promiseQueue.then(() => this._sendWithProtocol(this._createStreamItemMessage(streamId, item)));\n                },\n            });\n        }\n    }\n    _replaceStreamingParams(args) {\n        const streams = [];\n        const streamIds = [];\n        for (let i = 0; i < args.length; i++) {\n            const argument = args[i];\n            if (this._isObservable(argument)) {\n                const streamId = this._invocationId;\n                this._invocationId++;\n                // Store the stream for later use\n                streams[streamId] = argument;\n                streamIds.push(streamId.toString());\n                // remove stream from args\n                args.splice(i, 1);\n            }\n        }\n        return [streams, streamIds];\n    }\n    _isObservable(arg) {\n        // This allows other stream implementations to just work (like rxjs)\n        return arg && arg.subscribe && typeof arg.subscribe === \"function\";\n    }\n    _createStreamInvocation(methodName, args, streamIds) {\n        const invocationId = this._invocationId;\n        this._invocationId++;\n        if (streamIds.length !== 0) {\n            return {\n                arguments: args,\n                invocationId: invocationId.toString(),\n                streamIds,\n                target: methodName,\n                type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_2__.MessageType.StreamInvocation,\n            };\n        }\n        else {\n            return {\n                arguments: args,\n                invocationId: invocationId.toString(),\n                target: methodName,\n                type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_2__.MessageType.StreamInvocation,\n            };\n        }\n    }\n    _createCancelInvocation(id) {\n        return {\n            invocationId: id,\n            type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_2__.MessageType.CancelInvocation,\n        };\n    }\n    _createStreamItemMessage(id, item) {\n        return {\n            invocationId: id,\n            item,\n            type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_2__.MessageType.StreamItem,\n        };\n    }\n    _createCompletionMessage(id, error, result) {\n        if (error) {\n            return {\n                error,\n                invocationId: id,\n                type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_2__.MessageType.Completion,\n            };\n        }\n        return {\n            invocationId: id,\n            result,\n            type: _IHubProtocol__WEBPACK_IMPORTED_MODULE_2__.MessageType.Completion,\n        };\n    }\n}\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/HubConnection.ts?");

/***/ }),

/***/ "./src/HubConnectionBuilder.ts":
/*!*************************************!*\
  !*** ./src/HubConnectionBuilder.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HubConnectionBuilder: () => (/* binding */ HubConnectionBuilder)\n/* harmony export */ });\n/* harmony import */ var _DefaultReconnectPolicy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultReconnectPolicy */ \"./src/DefaultReconnectPolicy.ts\");\n/* harmony import */ var _HttpConnection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HttpConnection */ \"./src/HttpConnection.ts\");\n/* harmony import */ var _HubConnection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HubConnection */ \"./src/HubConnection.ts\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ILogger */ \"./src/ILogger.ts\");\n/* harmony import */ var _JsonHubProtocol__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./JsonHubProtocol */ \"./src/JsonHubProtocol.ts\");\n/* harmony import */ var _Loggers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Loggers */ \"./src/Loggers.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Utils */ \"./src/Utils.ts\");\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n\n\n\n\n\n\nconst LogLevelNameMapping = {\n    trace: _ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Trace,\n    debug: _ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Debug,\n    info: _ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Information,\n    information: _ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Information,\n    warn: _ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Warning,\n    warning: _ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Warning,\n    error: _ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Error,\n    critical: _ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.Critical,\n    none: _ILogger__WEBPACK_IMPORTED_MODULE_3__.LogLevel.None,\n};\nfunction parseLogLevel(name) {\n    // Case-insensitive matching via lower-casing\n    // Yes, I know case-folding is a complicated problem in Unicode, but we only support\n    // the ASCII strings defined in LogLevelNameMapping anyway, so it's fine -anurse.\n    const mapping = LogLevelNameMapping[name.toLowerCase()];\n    if (typeof mapping !== \"undefined\") {\n        return mapping;\n    }\n    else {\n        throw new Error(`Unknown log level: ${name}`);\n    }\n}\n/** A builder for configuring {@link @microsoft/signalr.HubConnection} instances. */\nclass HubConnectionBuilder {\n    configureLogging(logging) {\n        _Utils__WEBPACK_IMPORTED_MODULE_6__.Arg.isRequired(logging, \"logging\");\n        if (isLogger(logging)) {\n            this.logger = logging;\n        }\n        else if (typeof logging === \"string\") {\n            const logLevel = parseLogLevel(logging);\n            this.logger = new _Utils__WEBPACK_IMPORTED_MODULE_6__.ConsoleLogger(logLevel);\n        }\n        else {\n            this.logger = new _Utils__WEBPACK_IMPORTED_MODULE_6__.ConsoleLogger(logging);\n        }\n        return this;\n    }\n    withUrl(url, transportTypeOrOptions) {\n        _Utils__WEBPACK_IMPORTED_MODULE_6__.Arg.isRequired(url, \"url\");\n        _Utils__WEBPACK_IMPORTED_MODULE_6__.Arg.isNotEmpty(url, \"url\");\n        this.url = url;\n        // Flow-typing knows where it's at. Since HttpTransportType is a number and IHttpConnectionOptions is guaranteed\n        // to be an object, we know (as does TypeScript) this comparison is all we need to figure out which overload was called.\n        if (typeof transportTypeOrOptions === \"object\") {\n            this.httpConnectionOptions = Object.assign(Object.assign({}, this.httpConnectionOptions), transportTypeOrOptions);\n        }\n        else {\n            this.httpConnectionOptions = Object.assign(Object.assign({}, this.httpConnectionOptions), { transport: transportTypeOrOptions });\n        }\n        return this;\n    }\n    /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified Hub Protocol.\n     *\n     * @param {IHubProtocol} protocol The {@link @microsoft/signalr.IHubProtocol} implementation to use.\n     */\n    withHubProtocol(protocol) {\n        _Utils__WEBPACK_IMPORTED_MODULE_6__.Arg.isRequired(protocol, \"protocol\");\n        this.protocol = protocol;\n        return this;\n    }\n    withAutomaticReconnect(retryDelaysOrReconnectPolicy) {\n        if (this.reconnectPolicy) {\n            throw new Error(\"A reconnectPolicy has already been set.\");\n        }\n        if (!retryDelaysOrReconnectPolicy) {\n            this.reconnectPolicy = new _DefaultReconnectPolicy__WEBPACK_IMPORTED_MODULE_0__.DefaultReconnectPolicy();\n        }\n        else if (Array.isArray(retryDelaysOrReconnectPolicy)) {\n            this.reconnectPolicy = new _DefaultReconnectPolicy__WEBPACK_IMPORTED_MODULE_0__.DefaultReconnectPolicy(retryDelaysOrReconnectPolicy);\n        }\n        else {\n            this.reconnectPolicy = retryDelaysOrReconnectPolicy;\n        }\n        return this;\n    }\n    /** Creates a {@link @microsoft/signalr.HubConnection} from the configuration options specified in this builder.\n     *\n     * @returns {HubConnection} The configured {@link @microsoft/signalr.HubConnection}.\n     */\n    build() {\n        // If httpConnectionOptions has a logger, use it. Otherwise, override it with the one\n        // provided to configureLogger\n        const httpConnectionOptions = this.httpConnectionOptions || {};\n        // If it's 'null', the user **explicitly** asked for null, don't mess with it.\n        if (httpConnectionOptions.logger === undefined) {\n            // If our logger is undefined or null, that's OK, the HttpConnection constructor will handle it.\n            httpConnectionOptions.logger = this.logger;\n        }\n        // Now create the connection\n        if (!this.url) {\n            throw new Error(\"The 'HubConnectionBuilder.withUrl' method must be called before building the connection.\");\n        }\n        const connection = new _HttpConnection__WEBPACK_IMPORTED_MODULE_1__.HttpConnection(this.url, httpConnectionOptions);\n        return _HubConnection__WEBPACK_IMPORTED_MODULE_2__.HubConnection.create(connection, this.logger || _Loggers__WEBPACK_IMPORTED_MODULE_5__.NullLogger.instance, this.protocol || new _JsonHubProtocol__WEBPACK_IMPORTED_MODULE_4__.JsonHubProtocol(), this.reconnectPolicy);\n    }\n}\nfunction isLogger(logger) {\n    return logger.log !== undefined;\n}\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/HubConnectionBuilder.ts?");

/***/ }),

/***/ "./src/IHubProtocol.ts":
/*!*****************************!*\
  !*** ./src/IHubProtocol.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MessageType: () => (/* binding */ MessageType)\n/* harmony export */ });\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n/** Defines the type of a Hub Message. */\nvar MessageType;\n(function (MessageType) {\n    /** Indicates the message is an Invocation message and implements the {@link @microsoft/signalr.InvocationMessage} interface. */\n    MessageType[MessageType[\"Invocation\"] = 1] = \"Invocation\";\n    /** Indicates the message is a StreamItem message and implements the {@link @microsoft/signalr.StreamItemMessage} interface. */\n    MessageType[MessageType[\"StreamItem\"] = 2] = \"StreamItem\";\n    /** Indicates the message is a Completion message and implements the {@link @microsoft/signalr.CompletionMessage} interface. */\n    MessageType[MessageType[\"Completion\"] = 3] = \"Completion\";\n    /** Indicates the message is a Stream Invocation message and implements the {@link @microsoft/signalr.StreamInvocationMessage} interface. */\n    MessageType[MessageType[\"StreamInvocation\"] = 4] = \"StreamInvocation\";\n    /** Indicates the message is a Cancel Invocation message and implements the {@link @microsoft/signalr.CancelInvocationMessage} interface. */\n    MessageType[MessageType[\"CancelInvocation\"] = 5] = \"CancelInvocation\";\n    /** Indicates the message is a Ping message and implements the {@link @microsoft/signalr.PingMessage} interface. */\n    MessageType[MessageType[\"Ping\"] = 6] = \"Ping\";\n    /** Indicates the message is a Close message and implements the {@link @microsoft/signalr.CloseMessage} interface. */\n    MessageType[MessageType[\"Close\"] = 7] = \"Close\";\n})(MessageType || (MessageType = {}));\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/IHubProtocol.ts?");

/***/ }),

/***/ "./src/ILogger.ts":
/*!************************!*\
  !*** ./src/ILogger.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel)\n/* harmony export */ });\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// These values are designed to match the ASP.NET Log Levels since that's the pattern we're emulating here.\n/** Indicates the severity of a log message.\n *\n * Log Levels are ordered in increasing severity. So `Debug` is more severe than `Trace`, etc.\n */\nvar LogLevel;\n(function (LogLevel) {\n    /** Log level for very low severity diagnostic messages. */\n    LogLevel[LogLevel[\"Trace\"] = 0] = \"Trace\";\n    /** Log level for low severity diagnostic messages. */\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n    /** Log level for informational diagnostic messages. */\n    LogLevel[LogLevel[\"Information\"] = 2] = \"Information\";\n    /** Log level for diagnostic messages that indicate a non-fatal problem. */\n    LogLevel[LogLevel[\"Warning\"] = 3] = \"Warning\";\n    /** Log level for diagnostic messages that indicate a failure in the current operation. */\n    LogLevel[LogLevel[\"Error\"] = 4] = \"Error\";\n    /** Log level for diagnostic messages that indicate a failure that will terminate the entire application. */\n    LogLevel[LogLevel[\"Critical\"] = 5] = \"Critical\";\n    /** The highest possible log level. Used when configuring logging to indicate that no log messages should be emitted. */\n    LogLevel[LogLevel[\"None\"] = 6] = \"None\";\n})(LogLevel || (LogLevel = {}));\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/ILogger.ts?");

/***/ }),

/***/ "./src/ITransport.ts":
/*!***************************!*\
  !*** ./src/ITransport.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HttpTransportType: () => (/* binding */ HttpTransportType),\n/* harmony export */   TransferFormat: () => (/* binding */ TransferFormat)\n/* harmony export */ });\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// This will be treated as a bit flag in the future, so we keep it using power-of-two values.\n/** Specifies a specific HTTP transport type. */\nvar HttpTransportType;\n(function (HttpTransportType) {\n    /** Specifies no transport preference. */\n    HttpTransportType[HttpTransportType[\"None\"] = 0] = \"None\";\n    /** Specifies the SocketTasks transport. */\n    HttpTransportType[HttpTransportType[\"SocketTasks\"] = 1] = \"SocketTasks\";\n    /** Specifies the Server-Sent Events transport. */\n    HttpTransportType[HttpTransportType[\"ServerSentEvents\"] = 2] = \"ServerSentEvents\";\n    /** Specifies the Long Polling transport. */\n    HttpTransportType[HttpTransportType[\"LongPolling\"] = 4] = \"LongPolling\";\n})(HttpTransportType || (HttpTransportType = {}));\n/** Specifies the transfer format for a connection. */\nvar TransferFormat;\n(function (TransferFormat) {\n    /** Specifies that only text data will be transmitted over the connection. */\n    TransferFormat[TransferFormat[\"Text\"] = 1] = \"Text\";\n    /** Specifies that binary data will be transmitted over the connection. */\n    TransferFormat[TransferFormat[\"Binary\"] = 2] = \"Binary\";\n})(TransferFormat || (TransferFormat = {}));\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/ITransport.ts?");

/***/ }),

/***/ "./src/JsonHubProtocol.ts":
/*!********************************!*\
  !*** ./src/JsonHubProtocol.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JsonHubProtocol: () => (/* binding */ JsonHubProtocol)\n/* harmony export */ });\n/* harmony import */ var _IHubProtocol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IHubProtocol */ \"./src/IHubProtocol.ts\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ILogger */ \"./src/ILogger.ts\");\n/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ITransport */ \"./src/ITransport.ts\");\n/* harmony import */ var _Loggers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Loggers */ \"./src/Loggers.ts\");\n/* harmony import */ var _TextMessageFormat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TextMessageFormat */ \"./src/TextMessageFormat.ts\");\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n\n\n\n\nconst JSON_HUB_PROTOCOL_NAME = \"json\";\n/** Implements the JSON Hub Protocol. */\nclass JsonHubProtocol {\n    constructor() {\n        /** @inheritDoc */\n        this.name = JSON_HUB_PROTOCOL_NAME;\n        /** @inheritDoc */\n        this.version = 1;\n        /** @inheritDoc */\n        this.transferFormat = _ITransport__WEBPACK_IMPORTED_MODULE_2__.TransferFormat.Text;\n    }\n    /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.\n     *\n     * @param {string} input A string containing the serialized representation.\n     * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.\n     */\n    parseMessages(input, logger) {\n        // The interface does allow \"ArrayBuffer\" to be passed in, but this implementation does not. So let's throw a useful error.\n        if (typeof input !== \"string\") {\n            throw new Error(\"Invalid input for JSON hub protocol. Expected a string.\");\n        }\n        if (!input) {\n            return [];\n        }\n        if (logger === null) {\n            logger = _Loggers__WEBPACK_IMPORTED_MODULE_3__.NullLogger.instance;\n        }\n        // Parse the messages\n        const messages = _TextMessageFormat__WEBPACK_IMPORTED_MODULE_4__.TextMessageFormat.parse(input);\n        const hubMessages = [];\n        for (const message of messages) {\n            const parsedMessage = JSON.parse(message);\n            if (typeof parsedMessage.type !== \"number\") {\n                throw new Error(\"Invalid payload.\");\n            }\n            switch (parsedMessage.type) {\n                case _IHubProtocol__WEBPACK_IMPORTED_MODULE_0__.MessageType.Invocation:\n                    this._isInvocationMessage(parsedMessage);\n                    break;\n                case _IHubProtocol__WEBPACK_IMPORTED_MODULE_0__.MessageType.StreamItem:\n                    this._isStreamItemMessage(parsedMessage);\n                    break;\n                case _IHubProtocol__WEBPACK_IMPORTED_MODULE_0__.MessageType.Completion:\n                    this._isCompletionMessage(parsedMessage);\n                    break;\n                case _IHubProtocol__WEBPACK_IMPORTED_MODULE_0__.MessageType.Ping:\n                    // Single value, no need to validate\n                    break;\n                case _IHubProtocol__WEBPACK_IMPORTED_MODULE_0__.MessageType.Close:\n                    // All optional values, no need to validate\n                    break;\n                default:\n                    // Future protocol changes can add message types, old clients can ignore them\n                    logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__.LogLevel.Information, \"Unknown message type '\" + parsedMessage.type + \"' ignored.\");\n                    continue;\n            }\n            hubMessages.push(parsedMessage);\n        }\n        return hubMessages;\n    }\n    /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string and returns it.\n     *\n     * @param {HubMessage} message The message to write.\n     * @returns {string} A string containing the serialized representation of the message.\n     */\n    writeMessage(message) {\n        return _TextMessageFormat__WEBPACK_IMPORTED_MODULE_4__.TextMessageFormat.write(JSON.stringify(message));\n    }\n    _isInvocationMessage(message) {\n        this._assertNotEmptyString(message.target, \"Invalid payload for Invocation message.\");\n        if (message.invocationId !== undefined) {\n            this._assertNotEmptyString(message.invocationId, \"Invalid payload for Invocation message.\");\n        }\n    }\n    _isStreamItemMessage(message) {\n        this._assertNotEmptyString(message.invocationId, \"Invalid payload for StreamItem message.\");\n        if (message.item === undefined) {\n            throw new Error(\"Invalid payload for StreamItem message.\");\n        }\n    }\n    _isCompletionMessage(message) {\n        if (message.result && message.error) {\n            throw new Error(\"Invalid payload for Completion message.\");\n        }\n        if (!message.result && message.error) {\n            this._assertNotEmptyString(message.error, \"Invalid payload for Completion message.\");\n        }\n        this._assertNotEmptyString(message.invocationId, \"Invalid payload for Completion message.\");\n    }\n    _assertNotEmptyString(value, errorMessage) {\n        if (typeof value !== \"string\" || value === \"\") {\n            throw new Error(errorMessage);\n        }\n    }\n}\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/JsonHubProtocol.ts?");

/***/ }),

/***/ "./src/Loggers.ts":
/*!************************!*\
  !*** ./src/Loggers.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NullLogger: () => (/* binding */ NullLogger)\n/* harmony export */ });\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n/** A logger that does nothing when log messages are sent to it. */\nclass NullLogger {\n    constructor() { }\n    /** @inheritDoc */\n    // eslint-disable-next-line\n    log(_logLevel, _message) {\n    }\n}\n/** The singleton instance of the {@link @microsoft/signalr.NullLogger}. */\nNullLogger.instance = new NullLogger();\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/Loggers.ts?");

/***/ }),

/***/ "./src/LongPollingTransport.ts":
/*!*************************************!*\
  !*** ./src/LongPollingTransport.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LongPollingTransport: () => (/* binding */ LongPollingTransport)\n/* harmony export */ });\n/* harmony import */ var _AbortController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbortController */ \"./src/AbortController.ts\");\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Errors */ \"./src/Errors.ts\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ILogger */ \"./src/ILogger.ts\");\n/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ITransport */ \"./src/ITransport.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Utils */ \"./src/Utils.ts\");\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n// Not exported from 'index', this type is internal.\n/** @private */\nclass LongPollingTransport {\n    // This is an internal type, not exported from 'index' so this is really just internal.\n    get pollAborted() {\n        return this._pollAbort.aborted;\n    }\n    constructor(httpClient, logger, options) {\n        this._httpClient = httpClient;\n        this._logger = logger;\n        this._pollAbort = new _AbortController__WEBPACK_IMPORTED_MODULE_0__.AbortController();\n        this._options = options;\n        this._running = false;\n        this.onreceive = null;\n        this.onclose = null;\n    }\n    connect(url, transferFormat) {\n        return __awaiter(this, void 0, void 0, function* () {\n            _Utils__WEBPACK_IMPORTED_MODULE_4__.Arg.isRequired(url, \"url\");\n            _Utils__WEBPACK_IMPORTED_MODULE_4__.Arg.isRequired(transferFormat, \"transferFormat\");\n            _Utils__WEBPACK_IMPORTED_MODULE_4__.Arg.isIn(transferFormat, _ITransport__WEBPACK_IMPORTED_MODULE_3__.TransferFormat, \"transferFormat\");\n            this._url = url;\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Trace, \"(LongPolling transport) Connecting.\");\n            // Allow binary format on Node and Browsers that support binary content (indicated by the presence of responseType property)\n            if (transferFormat === _ITransport__WEBPACK_IMPORTED_MODULE_3__.TransferFormat.Binary &&\n                (typeof XMLHttpRequest !== \"undefined\" && typeof new XMLHttpRequest().responseType !== \"string\")) {\n                throw new Error(\"Binary protocols over XmlHttpRequest not implementing advanced features are not supported.\");\n            }\n            const [name, value] = (0,_Utils__WEBPACK_IMPORTED_MODULE_4__.getUserAgentHeader)();\n            const headers = Object.assign({ [name]: value }, this._options.headers);\n            const pollOptions = {\n                abortSignal: this._pollAbort.signal,\n                headers,\n                timeout: 100000,\n                //withCredentials: this._options.withCredentials,\n            };\n            if (transferFormat === _ITransport__WEBPACK_IMPORTED_MODULE_3__.TransferFormat.Binary) {\n                pollOptions.responseType = \"arraybuffer\";\n            }\n            // Make initial long polling request\n            // Server uses first long polling request to finish initializing connection and it returns without data\n            const pollUrl = `${url}&_=${Date.now()}`;\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);\n            const response = yield this._httpClient.get(pollUrl, pollOptions);\n            if (response.statusCode !== 200) {\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);\n                // Mark running as false so that the poll immediately ends and runs the close logic\n                this._closeError = new _Errors__WEBPACK_IMPORTED_MODULE_1__.HttpError(response.statusText || \"\", response.statusCode);\n                this._running = false;\n            }\n            else {\n                this._running = true;\n            }\n            this._receiving = this._poll(this._url, pollOptions);\n        });\n    }\n    _poll(url, pollOptions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                while (this._running) {\n                    try {\n                        const pollUrl = `${url}&_=${Date.now()}`;\n                        this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Trace, `(LongPolling transport) polling: ${pollUrl}.`);\n                        const response = yield this._httpClient.get(pollUrl, pollOptions);\n                        if (response.statusCode === 204) {\n                            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Information, \"(LongPolling transport) Poll terminated by server.\");\n                            this._running = false;\n                        }\n                        else if (response.statusCode !== 200) {\n                            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Error, `(LongPolling transport) Unexpected response code: ${response.statusCode}.`);\n                            // Unexpected status code\n                            this._closeError = new _Errors__WEBPACK_IMPORTED_MODULE_1__.HttpError(response.statusText || \"\", response.statusCode);\n                            this._running = false;\n                        }\n                        else {\n                            // Process the response\n                            if (response.content) {\n                                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Trace, `(LongPolling transport) data received. ${(0,_Utils__WEBPACK_IMPORTED_MODULE_4__.getDataDetail)(response.content, this._options.logMessageContent)}.`);\n                                if (this.onreceive) {\n                                    this.onreceive(response.content);\n                                }\n                            }\n                            else {\n                                // This is another way timeout manifest.\n                                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\n                            }\n                        }\n                    }\n                    catch (e) {\n                        if (!this._running) {\n                            // Log but disregard errors that occur after stopping\n                            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Trace, `(LongPolling transport) Poll errored after shutdown: ${e.message}`);\n                        }\n                        else {\n                            if (e instanceof _Errors__WEBPACK_IMPORTED_MODULE_1__.TimeoutError) {\n                                // Ignore timeouts and reissue the poll.\n                                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Trace, \"(LongPolling transport) Poll timed out, reissuing.\");\n                            }\n                            else {\n                                // Close the connection with the error as the result.\n                                this._closeError = e;\n                                this._running = false;\n                            }\n                        }\n                    }\n                }\n            }\n            finally {\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Trace, \"(LongPolling transport) Polling complete.\");\n                // We will reach here with pollAborted==false when the server returned a response causing the transport to stop.\n                // If pollAborted==true then client initiated the stop and the stop method will raise the close event after DELETE is sent.\n                if (!this.pollAborted) {\n                    this._raiseOnClose();\n                }\n            }\n        });\n    }\n    send(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this._running) {\n                return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\n            }\n            return (0,_Utils__WEBPACK_IMPORTED_MODULE_4__.sendMessage)(this._logger, \"LongPolling\", this._httpClient, this._url, data, this._options);\n        });\n    }\n    stop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Trace, \"(LongPolling transport) Stopping polling.\");\n            // Tell receiving loop to stop, abort any current request, and then wait for it to finish\n            this._running = false;\n            this._pollAbort.abort();\n            try {\n                yield this._receiving;\n                // Send DELETE to clean up long polling on the server\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Trace, `(LongPolling transport) sending DELETE request to ${this._url}.`);\n                const headers = {};\n                const [name, value] = (0,_Utils__WEBPACK_IMPORTED_MODULE_4__.getUserAgentHeader)();\n                headers[name] = value;\n                const deleteOptions = {\n                    headers: Object.assign(Object.assign({}, headers), this._options.headers),\n                    timeout: this._options.timeout,\n                    //withCredentials: this._options.withCredentials,\n                };\n                yield this._httpClient.delete(this._url, deleteOptions);\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Trace, \"(LongPolling transport) DELETE request sent.\");\n            }\n            finally {\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Trace, \"(LongPolling transport) Stop finished.\");\n                // Raise close event here instead of in polling\n                // It needs to happen after the DELETE request is sent\n                this._raiseOnClose();\n            }\n        });\n    }\n    _raiseOnClose() {\n        if (this.onclose) {\n            let logMessage = \"(LongPolling transport) Firing onclose event.\";\n            if (this._closeError) {\n                logMessage += \" Error: \" + this._closeError;\n            }\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Trace, logMessage);\n            this.onclose(this._closeError);\n        }\n    }\n}\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/LongPollingTransport.ts?");

/***/ }),

/***/ "./src/ServerSentEventsTransport.ts":
/*!******************************************!*\
  !*** ./src/ServerSentEventsTransport.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ServerSentEventsTransport: () => (/* binding */ ServerSentEventsTransport)\n/* harmony export */ });\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ILogger */ \"./src/ILogger.ts\");\n/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ITransport */ \"./src/ITransport.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ \"./src/Utils.ts\");\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n/** @private */\nclass ServerSentEventsTransport {\n    constructor(httpClient, accessToken, logger, options) {\n        this._httpClient = httpClient;\n        this._accessToken = accessToken;\n        this._logger = logger;\n        this._options = options;\n        this.onreceive = null;\n        this.onclose = null;\n    }\n    connect(url, transferFormat) {\n        return __awaiter(this, void 0, void 0, function* () {\n            _Utils__WEBPACK_IMPORTED_MODULE_2__.Arg.isRequired(url, \"url\");\n            _Utils__WEBPACK_IMPORTED_MODULE_2__.Arg.isRequired(transferFormat, \"transferFormat\");\n            _Utils__WEBPACK_IMPORTED_MODULE_2__.Arg.isIn(transferFormat, _ITransport__WEBPACK_IMPORTED_MODULE_1__.TransferFormat, \"transferFormat\");\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Trace, \"(SSE transport) Connecting.\");\n            // set url before accessTokenFactory because this._url is only for send and we set the auth header instead of the query string for send\n            this._url = url;\n            if (this._accessToken) {\n                url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(this._accessToken)}`;\n            }\n            return new Promise((resolve, reject) => {\n                let opened = false;\n                if (transferFormat !== _ITransport__WEBPACK_IMPORTED_MODULE_1__.TransferFormat.Text) {\n                    reject(new Error(\"The Server-Sent Events transport only supports the 'Text' transfer format\"));\n                    return;\n                }\n                let eventSource;\n                if (_Utils__WEBPACK_IMPORTED_MODULE_2__.Platform.isBrowser || _Utils__WEBPACK_IMPORTED_MODULE_2__.Platform.isWebWorker) {\n                    eventSource = new this._options.EventSource(url, { withCredentials: this._options.withCredentials });\n                }\n                else {\n                    // Non-browser passes cookies via the dictionary\n                    const cookies = this._httpClient.getCookieString(url);\n                    const headers = {};\n                    headers.Cookie = cookies;\n                    const [name, value] = (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.getUserAgentHeader)();\n                    headers[name] = value;\n                    eventSource = new this._options.EventSource(url, { withCredentials: this._options.withCredentials, headers: Object.assign(Object.assign({}, headers), this._options.headers) });\n                }\n                try {\n                    eventSource.onmessage = (e) => {\n                        if (this.onreceive) {\n                            try {\n                                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Trace, `(SSE transport) data received. ${(0,_Utils__WEBPACK_IMPORTED_MODULE_2__.getDataDetail)(e.data, this._options.logMessageContent)}.`);\n                                this.onreceive(e.data);\n                            }\n                            catch (error) {\n                                if (error instanceof Error) {\n                                    this._close(error);\n                                }\n                                else {\n                                    this._close(new Error(\"An unknown error occurred.\"));\n                                }\n                                return;\n                            }\n                        }\n                    };\n                    // @ts-ignore: not using event on purpose\n                    eventSource.onerror = (e) => {\n                        // EventSource doesn't give any useful information about server side closes.\n                        if (opened) {\n                            this._close();\n                        }\n                        else {\n                            reject(new Error(\"EventSource failed to connect. The connection could not be found on the server,\"\n                                + \" either the connection ID is not present on the server, or a proxy is refusing/buffering the connection.\"\n                                + \" If you have multiple servers check that sticky sessions are enabled.\"));\n                        }\n                    };\n                    eventSource.onopen = () => {\n                        this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Information, `SSE connected to ${this._url}`);\n                        this._eventSource = eventSource;\n                        opened = true;\n                        resolve();\n                    };\n                }\n                catch (e) {\n                    reject(e);\n                    return;\n                }\n            });\n        });\n    }\n    send(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this._eventSource) {\n                return Promise.reject(new Error(\"Cannot send until the transport is connected\"));\n            }\n            return (0,_Utils__WEBPACK_IMPORTED_MODULE_2__.sendMessage)(this._logger, \"SSE\", this._httpClient, this._url, data, this._options);\n        });\n    }\n    stop() {\n        this._close();\n        return Promise.resolve();\n    }\n    _close(e) {\n        if (this._eventSource) {\n            this._eventSource.close();\n            this._eventSource = undefined;\n            if (this.onclose) {\n                this.onclose(e);\n            }\n        }\n    }\n}\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/ServerSentEventsTransport.ts?");

/***/ }),

/***/ "./src/Subject.ts":
/*!************************!*\
  !*** ./src/Subject.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Subject: () => (/* binding */ Subject)\n/* harmony export */ });\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils */ \"./src/Utils.ts\");\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n/** Stream implementation to stream items to the server. */\nclass Subject {\n    constructor() {\n        this.observers = [];\n    }\n    next(item) {\n        for (const observer of this.observers) {\n            observer.next(item);\n        }\n    }\n    error(err) {\n        for (const observer of this.observers) {\n            if (observer.error) {\n                observer.error(err);\n            }\n        }\n    }\n    complete() {\n        for (const observer of this.observers) {\n            if (observer.complete) {\n                observer.complete();\n            }\n        }\n    }\n    subscribe(observer) {\n        this.observers.push(observer);\n        return new _Utils__WEBPACK_IMPORTED_MODULE_0__.SubjectSubscription(this, observer);\n    }\n}\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/Subject.ts?");

/***/ }),

/***/ "./src/TextMessageFormat.ts":
/*!**********************************!*\
  !*** ./src/TextMessageFormat.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextMessageFormat: () => (/* binding */ TextMessageFormat)\n/* harmony export */ });\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n// Not exported from index\n/** @private */\nclass TextMessageFormat {\n    static write(output) {\n        return `${output}${TextMessageFormat.RecordSeparator}`;\n    }\n    static parse(input) {\n        if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {\n            throw new Error(\"Message is incomplete.\");\n        }\n        const messages = input.split(TextMessageFormat.RecordSeparator);\n        messages.pop();\n        return messages;\n    }\n}\nTextMessageFormat.RecordSeparatorCode = 0x1e;\nTextMessageFormat.RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/TextMessageFormat.ts?");

/***/ }),

/***/ "./src/UniHttpClient.ts":
/*!******************************!*\
  !*** ./src/UniHttpClient.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   UniHttpClient: () => (/* binding */ UniHttpClient)\n/* harmony export */ });\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors */ \"./src/Errors.ts\");\n/* harmony import */ var _HttpClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HttpClient */ \"./src/HttpClient.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils */ \"./src/Utils.ts\");\n\n\n\n//import { RequestOptions } from \"uni-app/lib/uni\";\n//import { uni } from \"uni-app/lib/uni\";\nclass UniHttpClient extends _HttpClient__WEBPACK_IMPORTED_MODULE_1__.HttpClient {\n    constructor(logger) {\n        super();\n        this._logger = logger;\n    }\n    /** @inheritDoc */\n    send(request) {\n        // Check that abort was not signaled before calling send\n        if (request.abortSignal && request.abortSignal.aborted) {\n            return Promise.reject(new _Errors__WEBPACK_IMPORTED_MODULE_0__.AbortError());\n        }\n        if (!request.method) {\n            return Promise.reject(new Error(\"No method defined.\"));\n        }\n        if (!request.url) {\n            return Promise.reject(new Error(\"No url defined.\"));\n        }\n        request.headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n        if (request.content === \"\") {\n            request.content = undefined;\n        }\n        if (request.content) {\n            // Explicitly setting the Content-Type header for React Native on Android platform.\n            if ((0,_Utils__WEBPACK_IMPORTED_MODULE_2__.isArrayBuffer)(request.content)) {\n                request.headers[\"Content-Type\"] = \"application/octet-stream\";\n            }\n            else {\n                request.headers[\"Content-Type\"] = \"text/plain;charset=UTF-8\";\n            }\n        }\n        let requstTask = uni.requestWithCookie(request);\n        let options = request;\n        return new Promise((resolve, reject) => {\n            options.success = (response) => {\n                console.log(\"success HttpResponse\", response);\n                let res = new _HttpClient__WEBPACK_IMPORTED_MODULE_1__.HttpResponse(response.statusCode, response.errMsg, response.data);\n                return res;\n            };\n            options.fail = (response) => {\n                console.log(\"fail HttpResponse\", response);\n                return new Error(response === null || response === void 0 ? void 0 : response.errMsg);\n            };\n            requstTask = uni.requestWithCookie(request);\n        });\n    }\n}\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/UniHttpClient.ts?");

/***/ }),

/***/ "./src/Utils.ts":
/*!**********************!*\
  !*** ./src/Utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Arg: () => (/* binding */ Arg),\n/* harmony export */   ConsoleLogger: () => (/* binding */ ConsoleLogger),\n/* harmony export */   Platform: () => (/* binding */ Platform),\n/* harmony export */   SubjectSubscription: () => (/* binding */ SubjectSubscription),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   constructUserAgent: () => (/* binding */ constructUserAgent),\n/* harmony export */   createLogger: () => (/* binding */ createLogger),\n/* harmony export */   formatArrayBuffer: () => (/* binding */ formatArrayBuffer),\n/* harmony export */   getDataDetail: () => (/* binding */ getDataDetail),\n/* harmony export */   getErrorString: () => (/* binding */ getErrorString),\n/* harmony export */   getGlobalThis: () => (/* binding */ getGlobalThis),\n/* harmony export */   getUserAgentHeader: () => (/* binding */ getUserAgentHeader),\n/* harmony export */   isArrayBuffer: () => (/* binding */ isArrayBuffer),\n/* harmony export */   sendMessage: () => (/* binding */ sendMessage)\n/* harmony export */ });\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ILogger */ \"./src/ILogger.ts\");\n/* harmony import */ var _Loggers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Loggers */ \"./src/Loggers.ts\");\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n// Version token that will be replaced by the prepack command\n/** The version of the SignalR client. */\nconst VERSION = \"0.0.0-DEV_BUILD\";\n/** @private */\nclass Arg {\n    static isRequired(val, name) {\n        if (val === null || val === undefined) {\n            throw new Error(`The '${name}' argument is required.`);\n        }\n    }\n    static isNotEmpty(val, name) {\n        if (!val || val.match(/^\\s*$/)) {\n            throw new Error(`The '${name}' argument should not be empty.`);\n        }\n    }\n    static isIn(val, values, name) {\n        // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.\n        if (!(val in values)) {\n            throw new Error(`Unknown ${name} value: ${val}.`);\n        }\n    }\n}\n/** @private */\nclass Platform {\n    // react-native has a window but no document so we should check both\n    static get isBrowser() {\n        return typeof window === \"object\" && typeof window.document === \"object\";\n    }\n    // WebWorkers don't have a window object so the isBrowser check would fail\n    static get isWebWorker() {\n        return typeof self === \"object\" && \"importScripts\" in self;\n    }\n    // react-native has a window but no document\n    static get isReactNative() {\n        return typeof window === \"object\" && typeof window.document === \"undefined\";\n    }\n    // Node apps shouldn't have a window object, but WebWorkers don't either\n    // so we need to check for both WebWorker and window\n    static get isNode() {\n        return !this.isBrowser && !this.isWebWorker && !this.isReactNative;\n    }\n}\n/** @private */\nfunction getDataDetail(data, includeContent) {\n    let detail = \"\";\n    if (isArrayBuffer(data)) {\n        detail = `Binary data of length ${data.byteLength}`;\n        if (includeContent) {\n            detail += `. Content: '${formatArrayBuffer(data)}'`;\n        }\n    }\n    else if (typeof data === \"string\") {\n        detail = `String data of length ${data.length}`;\n        if (includeContent) {\n            detail += `. Content: '${data}'`;\n        }\n    }\n    return detail;\n}\n/** @private */\nfunction formatArrayBuffer(data) {\n    const view = new Uint8Array(data);\n    // Uint8Array.map only supports returning another Uint8Array?\n    let str = \"\";\n    view.forEach((num) => {\n        const pad = num < 16 ? \"0\" : \"\";\n        str += `0x${pad}${num.toString(16)} `;\n    });\n    // Trim of trailing space.\n    return str.substr(0, str.length - 1);\n}\n// Also in signalr-protocol-msgpack/Utils.ts\n/** @private */\nfunction isArrayBuffer(val) {\n    return val && typeof ArrayBuffer !== \"undefined\" &&\n        (val instanceof ArrayBuffer ||\n            // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof\n            (val.constructor && val.constructor.name === \"ArrayBuffer\"));\n}\n/** @private */\nfunction sendMessage(logger, transportName, httpClient, url, content, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const headers = {};\n        const [name, value] = getUserAgentHeader();\n        headers[name] = value;\n        logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Trace, `(${transportName} transport) sending data. ${getDataDetail(content, options.logMessageContent)}.`);\n        const responseType = isArrayBuffer(content) ? \"arraybuffer\" : \"text\";\n        const response = yield httpClient.post(url, {\n            content,\n            headers: Object.assign(Object.assign({}, headers), options.headers),\n            responseType,\n            timeout: options.timeout,\n            //withCredentials: options.withCredentials,\n        });\n        logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Trace, `(${transportName} transport) request complete. Response status: ${response.statusCode}.`);\n    });\n}\n/** @private */\nfunction createLogger(logger) {\n    if (logger === undefined) {\n        return new ConsoleLogger(_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Information);\n    }\n    if (logger === null) {\n        return _Loggers__WEBPACK_IMPORTED_MODULE_1__.NullLogger.instance;\n    }\n    if (logger.log !== undefined) {\n        return logger;\n    }\n    return new ConsoleLogger(logger);\n}\n/** @private */\nclass SubjectSubscription {\n    constructor(subject, observer) {\n        this._subject = subject;\n        this._observer = observer;\n    }\n    dispose() {\n        const index = this._subject.observers.indexOf(this._observer);\n        if (index > -1) {\n            this._subject.observers.splice(index, 1);\n        }\n        if (this._subject.observers.length === 0 && this._subject.cancelCallback) {\n            this._subject.cancelCallback().catch((_) => { });\n        }\n    }\n}\n/** @private */\nclass ConsoleLogger {\n    constructor(minimumLogLevel) {\n        this._minLevel = minimumLogLevel;\n        this.out = console;\n    }\n    log(logLevel, message) {\n        if (logLevel >= this._minLevel) {\n            const msg = `[${new Date().toISOString()}] ${_ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel[logLevel]}: ${message}`;\n            switch (logLevel) {\n                case _ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Critical:\n                case _ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Error:\n                    this.out.error(msg);\n                    break;\n                case _ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Warning:\n                    this.out.warn(msg);\n                    break;\n                case _ILogger__WEBPACK_IMPORTED_MODULE_0__.LogLevel.Information:\n                    this.out.info(msg);\n                    break;\n                default:\n                    // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug\n                    this.out.log(msg);\n                    break;\n            }\n        }\n    }\n}\n/** @private */\nfunction getUserAgentHeader() {\n    let userAgentHeaderName = \"X-SignalR-User-Agent\";\n    if (Platform.isNode) {\n        userAgentHeaderName = \"User-Agent\";\n    }\n    return [userAgentHeaderName, constructUserAgent(VERSION, getOsName(), getRuntime(), getRuntimeVersion())];\n}\n/** @private */\nfunction constructUserAgent(version, os, runtime, runtimeVersion) {\n    // Microsoft SignalR/[Version] ([Detailed Version]; [Operating System]; [Runtime]; [Runtime Version])\n    let userAgent = \"Microsoft SignalR/\";\n    const majorAndMinor = version.split(\".\");\n    userAgent += `${majorAndMinor[0]}.${majorAndMinor[1]}`;\n    userAgent += ` (${version}; `;\n    if (os && os !== \"\") {\n        userAgent += `${os}; `;\n    }\n    else {\n        userAgent += \"Unknown OS; \";\n    }\n    userAgent += `${runtime}`;\n    if (runtimeVersion) {\n        userAgent += `; ${runtimeVersion}`;\n    }\n    else {\n        userAgent += \"; Unknown Runtime Version\";\n    }\n    userAgent += \")\";\n    return userAgent;\n}\n// eslint-disable-next-line spaced-comment\n/*#__PURE__*/ function getOsName() {\n    if (Platform.isNode) {\n        switch (process.platform) {\n            case \"win32\":\n                return \"Windows NT\";\n            case \"darwin\":\n                return \"macOS\";\n            case \"linux\":\n                return \"Linux\";\n            default:\n                return process.platform;\n        }\n    }\n    else {\n        return \"\";\n    }\n}\n// eslint-disable-next-line spaced-comment\n/*#__PURE__*/ function getRuntimeVersion() {\n    if (Platform.isNode) {\n        return process.versions.node;\n    }\n    return undefined;\n}\nfunction getRuntime() {\n    if (Platform.isNode) {\n        return \"NodeJS\";\n    }\n    else {\n        return \"Browser\";\n    }\n}\n/** @private */\nfunction getErrorString(e) {\n    if (e.stack) {\n        return e.stack;\n    }\n    else if (e.message) {\n        return e.message;\n    }\n    return `${e}`;\n}\n/** @private */\nfunction getGlobalThis() {\n    // globalThis is semi-new and not available in Node until v12\n    if (typeof globalThis !== \"undefined\") {\n        return globalThis;\n    }\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    if (typeof window !== \"undefined\") {\n        return window;\n    }\n    if (typeof __webpack_require__.g !== \"undefined\") {\n        return __webpack_require__.g;\n    }\n    throw new Error(\"could not find global\");\n}\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/Utils.ts?");

/***/ }),

/***/ "./src/WebSocketTransport.ts":
/*!***********************************!*\
  !*** ./src/WebSocketTransport.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SocketTaskTransport: () => (/* binding */ SocketTaskTransport)\n/* harmony export */ });\n/* harmony import */ var _HeaderNames__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HeaderNames */ \"./src/HeaderNames.ts\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ILogger */ \"./src/ILogger.ts\");\n/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ITransport */ \"./src/ITransport.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils */ \"./src/Utils.ts\");\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n//import {\n//    SocketTask, OnSocketOpenCallbackResult, GeneralCallbackResult\n//    , OnSocketMessageCallbackResult\n//} from \"uni-app/lib/uni\";\n\n\n\n\n/** @private */\nclass SocketTaskTransport {\n    constructor(httpClient, accessTokenFactory, logger, logMessageContent, socketTaskConstructor, headers) {\n        this._logger = logger;\n        this._accessTokenFactory = accessTokenFactory;\n        this._logMessageContent = logMessageContent;\n        this._socketTaskConstructor = socketTaskConstructor;\n        this._httpClient = httpClient;\n        this.onreceive = null;\n        this.onclose = null;\n        this._headers = headers;\n        this._headers[\"Host\"];\n    }\n    connect(url, transferFormat) {\n        return __awaiter(this, void 0, void 0, function* () {\n            _Utils__WEBPACK_IMPORTED_MODULE_3__.Arg.isRequired(url, \"url\");\n            _Utils__WEBPACK_IMPORTED_MODULE_3__.Arg.isRequired(transferFormat, \"transferFormat\");\n            _Utils__WEBPACK_IMPORTED_MODULE_3__.Arg.isIn(transferFormat, _ITransport__WEBPACK_IMPORTED_MODULE_2__.TransferFormat, \"transferFormat\");\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__.LogLevel.Trace, \"(SocketTasks transport) Connecting.\");\n            let token;\n            if (this._accessTokenFactory) {\n                token = yield this._accessTokenFactory();\n            }\n            return new Promise((resolve, reject) => {\n                url = url.replace(/^http/, \"ws\");\n                let socketTask;\n                const cookies = this._httpClient.getCookieString(url);\n                let opened = false;\n                if (_Utils__WEBPACK_IMPORTED_MODULE_3__.Platform.isNode || _Utils__WEBPACK_IMPORTED_MODULE_3__.Platform.isReactNative) {\n                    const headers = {};\n                    const [name, value] = (0,_Utils__WEBPACK_IMPORTED_MODULE_3__.getUserAgentHeader)();\n                    headers[name] = value;\n                    if (token) {\n                        headers[_HeaderNames__WEBPACK_IMPORTED_MODULE_0__.HeaderNames.Authorization] = `Bearer ${token}`;\n                    }\n                    if (cookies) {\n                        headers[_HeaderNames__WEBPACK_IMPORTED_MODULE_0__.HeaderNames.Cookie] = cookies;\n                    }\n                    // Only pass headers when in non-browser environments\n                    socketTask = this._socketTaskConstructor.connectSocket({ url: url, header: headers });\n                }\n                else {\n                    if (token) {\n                        url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\n                    }\n                }\n                // if (!socketTask) {\n                //     // Chrome is not happy with passing 'undefined' as protocol\n                //     socketTask = new this._socketTaskConstructor(url);\n                // }\n                // if (transferFormat === TransferFormat.Binary) {\n                //     socketTask.binaryType = \"arraybuffer\";\n                // }\n                socketTask.onOpen((result) => {\n                    this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__.LogLevel.Information, `SocketTask connected to ${url}.`);\n                    this._socketTask = socketTask;\n                    opened = true;\n                    resolve(result.header);\n                });\n                socketTask.onError((result) => {\n                    let error = null;\n                    // ErrorEvent is a browser only type we need to check if the type exists before using it\n                    // if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\n                    //     error = event.error;\n                    // } else {\n                    //     error = \"There was an error with the transport\";\n                    // }\n                    error = result.errMsg;\n                    this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__.LogLevel.Information, `(SocketTasks transport) ${error}.`);\n                });\n                socketTask.onMessage((message) => {\n                    this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__.LogLevel.Trace, `(SocketTasks transport) data received. ${(0,_Utils__WEBPACK_IMPORTED_MODULE_3__.getDataDetail)(message.data, this._logMessageContent)}.`);\n                    if (this.onreceive) {\n                        try {\n                            const data = message.data || '';\n                            this.onreceive(data);\n                        }\n                        catch (error) {\n                            this._close(error);\n                            return;\n                        }\n                    }\n                });\n                socketTask.onClose(() => {\n                    // Don't call close handler if connection was never established\n                    // We'll reject the connect call instead\n                    let result = new CloseEvent(\"SocketTask closed\", { code: 1006, reason: \"SocketTask disconnected\" });\n                    if (opened) {\n                        this._close(result);\n                    }\n                    else {\n                        let error = null;\n                        // ErrorEvent is a browser only type we need to check if the type exists before using it\n                        if (typeof ErrorEvent !== \"undefined\" && result instanceof ErrorEvent) {\n                            error = result.error;\n                        }\n                        else {\n                            error = \"SocketTask failed to connect. The connection could not be found on the server,\"\n                                + \" either the endpoint may not be a SignalR endpoint,\"\n                                + \" the connection ID is not present on the server, or there is a proxy blocking SocketTasks.\"\n                                + \" If you have multiple servers check that sticky sessions are enabled.\";\n                        }\n                        reject(new Error(error));\n                    }\n                });\n            });\n        });\n    }\n    send(data) {\n        if (this._socketTask && this._socketTask.readyState === this._socketTaskConstructor.OPEN) {\n            this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__.LogLevel.Trace, `(SocketTasks transport) sending data. ${(0,_Utils__WEBPACK_IMPORTED_MODULE_3__.getDataDetail)(data, this._logMessageContent)}.`);\n            this._socketTask.send(data);\n            return Promise.resolve();\n        }\n        return Promise.reject(\"SocketTask is not in the OPEN state\");\n    }\n    stop() {\n        if (this._socketTask) {\n            // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\n            // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\n            this._close(undefined);\n        }\n        return Promise.resolve();\n    }\n    _close(event) {\n        // socketTask will be null if the transport did not start successfully\n        if (this._socketTask) {\n            // Clear websocket handlers because we are considering the socket closed now\n            this._socketTask.onClose = () => { };\n            this._socketTask.onMessage = () => { };\n            this._socketTask.onError = () => { };\n            this._socketTask.close({});\n            this._socketTask = undefined;\n        }\n        this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_1__.LogLevel.Trace, \"(SocketTasks transport) socket closed.\");\n        if (this.onclose) {\n            if (this._isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\n                this.onclose(new Error(`SocketTask closed with status code: ${event.code} (${event.reason || \"no reason given\"}).`));\n            }\n            else if (event instanceof Error) {\n                this.onclose(event);\n            }\n            else {\n                this.onclose();\n            }\n        }\n    }\n    _isCloseEvent(event) {\n        return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\n    }\n}\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/WebSocketTransport.ts?");

/***/ }),

/***/ "./src/XhrHttpClient.ts":
/*!******************************!*\
  !*** ./src/XhrHttpClient.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   XhrHttpClient: () => (/* binding */ XhrHttpClient)\n/* harmony export */ });\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors */ \"./src/Errors.ts\");\n/* harmony import */ var _HttpClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HttpClient */ \"./src/HttpClient.ts\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ILogger */ \"./src/ILogger.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Utils */ \"./src/Utils.ts\");\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n\n\n\nclass XhrHttpClient extends _HttpClient__WEBPACK_IMPORTED_MODULE_1__.HttpClient {\n    constructor(logger) {\n        super();\n        this._logger = logger;\n    }\n    /** @inheritDoc */\n    send(request) {\n        // Check that abort was not signaled before calling send\n        if (request.abortSignal && request.abortSignal.aborted) {\n            return Promise.reject(new _Errors__WEBPACK_IMPORTED_MODULE_0__.AbortError());\n        }\n        if (!request.method) {\n            return Promise.reject(new Error(\"No method defined.\"));\n        }\n        if (!request.url) {\n            return Promise.reject(new Error(\"No url defined.\"));\n        }\n        return new Promise((resolve, reject) => {\n            const xhr = new XMLHttpRequest();\n            xhr.open(request.method, request.url, true);\n            //xhr.withCredentials = request.withCredentials === undefined ? true : request.withCredentials;\n            xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\");\n            if (request.content === \"\") {\n                request.content = undefined;\n            }\n            if (request.content) {\n                // Explicitly setting the Content-Type header for React Native on Android platform.\n                if ((0,_Utils__WEBPACK_IMPORTED_MODULE_3__.isArrayBuffer)(request.content)) {\n                    xhr.setRequestHeader(\"Content-Type\", \"application/octet-stream\");\n                }\n                else {\n                    xhr.setRequestHeader(\"Content-Type\", \"text/plain;charset=UTF-8\");\n                }\n            }\n            const headers = request.headers;\n            if (headers) {\n                Object.keys(headers)\n                    .forEach((header) => {\n                    xhr.setRequestHeader(header, headers[header]);\n                });\n            }\n            if (request.responseType) {\n                xhr.responseType = request.responseType;\n            }\n            if (request.abortSignal) {\n                request.abortSignal.onabort = () => {\n                    xhr.abort();\n                    reject(new _Errors__WEBPACK_IMPORTED_MODULE_0__.AbortError());\n                };\n            }\n            if (request.timeout) {\n                xhr.timeout = request.timeout;\n            }\n            xhr.onload = () => {\n                if (request.abortSignal) {\n                    request.abortSignal.onabort = null;\n                }\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    resolve(new _HttpClient__WEBPACK_IMPORTED_MODULE_1__.HttpResponse(xhr.status, xhr.statusText, xhr.response || xhr.responseText));\n                }\n                else {\n                    reject(new _Errors__WEBPACK_IMPORTED_MODULE_0__.HttpError(xhr.response || xhr.responseText || xhr.statusText, xhr.status));\n                }\n            };\n            xhr.onerror = () => {\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Warning, `Error from HTTP request. ${xhr.status}: ${xhr.statusText}.`);\n                reject(new _Errors__WEBPACK_IMPORTED_MODULE_0__.HttpError(xhr.statusText, xhr.status));\n            };\n            xhr.ontimeout = () => {\n                this._logger.log(_ILogger__WEBPACK_IMPORTED_MODULE_2__.LogLevel.Warning, `Timeout from HTTP request.`);\n                reject(new _Errors__WEBPACK_IMPORTED_MODULE_0__.TimeoutError());\n            };\n            xhr.send(request.content);\n        });\n    }\n}\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/XhrHttpClient.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortError: () => (/* reexport safe */ _Errors__WEBPACK_IMPORTED_MODULE_0__.AbortError),\n/* harmony export */   DefaultHttpClient: () => (/* reexport safe */ _DefaultHttpClient__WEBPACK_IMPORTED_MODULE_2__.DefaultHttpClient),\n/* harmony export */   HttpClient: () => (/* reexport safe */ _HttpClient__WEBPACK_IMPORTED_MODULE_1__.HttpClient),\n/* harmony export */   HttpError: () => (/* reexport safe */ _Errors__WEBPACK_IMPORTED_MODULE_0__.HttpError),\n/* harmony export */   HttpResponse: () => (/* reexport safe */ _HttpClient__WEBPACK_IMPORTED_MODULE_1__.HttpResponse),\n/* harmony export */   HttpTransportType: () => (/* reexport safe */ _ITransport__WEBPACK_IMPORTED_MODULE_7__.HttpTransportType),\n/* harmony export */   HubConnection: () => (/* reexport safe */ _HubConnection__WEBPACK_IMPORTED_MODULE_3__.HubConnection),\n/* harmony export */   HubConnectionBuilder: () => (/* reexport safe */ _HubConnectionBuilder__WEBPACK_IMPORTED_MODULE_4__.HubConnectionBuilder),\n/* harmony export */   HubConnectionState: () => (/* reexport safe */ _HubConnection__WEBPACK_IMPORTED_MODULE_3__.HubConnectionState),\n/* harmony export */   JsonHubProtocol: () => (/* reexport safe */ _JsonHubProtocol__WEBPACK_IMPORTED_MODULE_9__.JsonHubProtocol),\n/* harmony export */   LogLevel: () => (/* reexport safe */ _ILogger__WEBPACK_IMPORTED_MODULE_6__.LogLevel),\n/* harmony export */   MessageType: () => (/* reexport safe */ _IHubProtocol__WEBPACK_IMPORTED_MODULE_5__.MessageType),\n/* harmony export */   NullLogger: () => (/* reexport safe */ _Loggers__WEBPACK_IMPORTED_MODULE_8__.NullLogger),\n/* harmony export */   Subject: () => (/* reexport safe */ _Subject__WEBPACK_IMPORTED_MODULE_10__.Subject),\n/* harmony export */   TimeoutError: () => (/* reexport safe */ _Errors__WEBPACK_IMPORTED_MODULE_0__.TimeoutError),\n/* harmony export */   TransferFormat: () => (/* reexport safe */ _ITransport__WEBPACK_IMPORTED_MODULE_7__.TransferFormat),\n/* harmony export */   VERSION: () => (/* reexport safe */ _Utils__WEBPACK_IMPORTED_MODULE_11__.VERSION)\n/* harmony export */ });\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors */ \"./src/Errors.ts\");\n/* harmony import */ var _HttpClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HttpClient */ \"./src/HttpClient.ts\");\n/* harmony import */ var _DefaultHttpClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DefaultHttpClient */ \"./src/DefaultHttpClient.ts\");\n/* harmony import */ var _HubConnection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./HubConnection */ \"./src/HubConnection.ts\");\n/* harmony import */ var _HubConnectionBuilder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./HubConnectionBuilder */ \"./src/HubConnectionBuilder.ts\");\n/* harmony import */ var _IHubProtocol__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./IHubProtocol */ \"./src/IHubProtocol.ts\");\n/* harmony import */ var _ILogger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ILogger */ \"./src/ILogger.ts\");\n/* harmony import */ var _ITransport__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ITransport */ \"./src/ITransport.ts\");\n/* harmony import */ var _Loggers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Loggers */ \"./src/Loggers.ts\");\n/* harmony import */ var _JsonHubProtocol__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./JsonHubProtocol */ \"./src/JsonHubProtocol.ts\");\n/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Subject */ \"./src/Subject.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Utils */ \"./src/Utils.ts\");\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://signalr_for_uniapp/./src/index.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;